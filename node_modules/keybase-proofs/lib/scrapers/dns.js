// Generated by IcedCoffeeScript 1.7.1-a
(function() {
  var BaseScraper, DnsScraper, constants, decode, dns, iced, make_ids, urlmod, v_codes, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  BaseScraper = require('./base').BaseScraper;

  constants = require('../constants').constants;

  v_codes = constants.v_codes;

  decode = require('pgp-utils').armor.decode;

  urlmod = require('url');

  make_ids = require('../base').make_ids;

  urlmod = require('url');

  dns = require('dns');

  exports.DnsScraper = DnsScraper = (function(_super) {
    __extends(DnsScraper, _super);

    function DnsScraper(opts) {
      DnsScraper.__super__.constructor.call(this, opts);
    }

    DnsScraper.prototype._check_args = function(args) {
      if (!(args.domain != null)) {
        return new Error("Bad args to DNS proof: no domain given");
      } else {
        return null;
      }
    };

    DnsScraper.prototype.make_url = function(_arg) {
      var domain;
      domain = _arg.domain;
      return "dns://" + (domain.toLowerCase());
    };

    DnsScraper.prototype.url_to_domain = function(u) {
      var _ref;
      return (_ref = urlmod.parse(u)) != null ? _ref.hostname : void 0;
    };

    DnsScraper.prototype.hunt2 = function(_arg, cb) {
      var domain, err, out, url;
      domain = _arg.domain;
      err = null;
      out = {};
      if (domain == null) {
        err = new Error("invalid arguments: expected a domain");
      } else {
        url = this.make_url({
          domain: domain
        });
        out = {
          api_url: url,
          human_url: url,
          remote_id: url,
          rc: v_codes.OK
        };
      }
      return cb(err, out);
    };

    DnsScraper.prototype._check_api_url = function(_arg) {
      var api_url, domain;
      api_url = _arg.api_url, domain = _arg.domain;
      return api_url.toLowerCase().indexOf(this.make_url({
        domain: domain
      })) >= 0;
    };

    DnsScraper.prototype._validate_text_check = function(_arg) {
      var err, med_id, msg, proof_text_check, signature, _ref;
      signature = _arg.signature, proof_text_check = _arg.proof_text_check;
      _ref = decode(signature), err = _ref[0], msg = _ref[1];
      if (err == null) {
        med_id = make_ids(msg.body).med_id;
        if (proof_text_check.indexOf(med_id) < 0) {
          err = new Error("Bad payload text_check");
        }
      }
      return err;
    };

    DnsScraper.prototype.check_status = function(_arg, cb) {
      var api_url, d, err, proof_text_check, rc, records, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      api_url = _arg.api_url, proof_text_check = _arg.proof_text_check;
      (function(_this) {
        return (function(__iced_k) {
          if ((d = _this.url_to_domain(api_url)) == null) {
            err = new Error("no domain found in URL " + api_url);
            return __iced_k(rc = v_codes.CONTENT_FAILURE);
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/proofs/src/scrapers/dns.iced",
                funcname: "DnsScraper.check_status"
              });
              dns.resolveTxt(d, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return records = arguments[1];
                  };
                })(),
                lineno: 69
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(rc = err != null ? (_this.log("| DNS error: " + err), v_codes.DNS_ERROR) : (__indexOf.call(records, proof_text_check) >= 0) ? v_codes.OK : (_this.log("| DNS failed; found TXT entries: " + (JSON.stringify(records))), v_codes.NOT_FOUND));
            });
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, rc);
        };
      })(this));
    };

    return DnsScraper;

  })(BaseScraper);

}).call(this);
