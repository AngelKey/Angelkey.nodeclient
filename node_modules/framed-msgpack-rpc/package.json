{
  "name": "framed-msgpack-rpc",
  "version": "1.1.3",
  "description": "Framed Msgpack RPC for node.js",
  "homepage": "https://github.com/maxtaco/node-framed-msgpack-rpc",
  "main": "./lib/main",
  "repository": {
    "type": "git",
    "url": "https://github.com/maxtaco/node-framed-msgpack-rpc.git"
  },
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "test": "iced test/all.iced"
  },
  "dependencies": {
    "iced-runtime": "0.0.1",
    "purepack": ">=1"
  },
  "devDependencies": {
    "colors": "~0.6.2",
    "random-json": "*",
    "iced-coffee-script": "*",
    "deep-equal": "*",
    "optimist": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "readme": "# Framed Msgpack RPC\n\nFramed Msgpack RPC (FMPRPC) is an RPC system for node.js.  It allows\nclients to call remote procedures on servers.  An RPC consists of: (1)\na simple string name; (2) an argument that is a single JSON object;\n(3) a reply that is also a single JSON object.  Of course, those\nobjects can be arrays, or dictionaries, so arguments and return values\ncan be complex and interesting.\n\nFMPRPC is a variant of the\n[Msgpack-RPC](http://redmine.msgpack.org/projects/msgpack/wiki/RPCDesign)\nprotocol specification for node.js.  Msgpack-RPC communicates\nbinary JSON objects that are efficiently encoded and decoded with the\n[MessagePack](http://msgpack.org) serialization format. \n\n\"Framed\" Msgpack-RPC differs from standard Msgpack-RPC in a small way:\nthe encoding of the length of the packet is prepended to each\npacket. This way, receivers can efficiently buffer data until a full\npacket is available to decode. In an event-based context like node.js,\nframing simplifies implementation, and yields a faster decoder,\nespecially for very large messages.\n\nBy convention, RPCs are grouped into _programs_, which can have\none or more _versions_.  Each (prog,vers) pair then has a collection\nof procedures, meaning an RPC is identified unabmiguously by a \n(prog,vers,proc) triple.  In practice, these three strings are\njoined with \".\" characters, and the dotted triple is the RPC name.\n\nDue to framing, this protocol is not compatible with existing\nMsgpack-RPC systems.  This implementation supports TCP transports only\nat the current time.\n\n## Example\n\nThe simplest way to write a server is with the `Server`\nclass as below:\n\n```javascript\nvar rpc = require('framed-msgpack-rpc');\nvar srv= new rpc.Server ({\n    programs : {\n        \"myprog.1\" : {\n            add : function(arg, response) {\n                response.result(arg.a + arg.b);\n            }\n        }\n    },\n    port : 8000 \n});\nsrv.listen(function (err) {\n    if (err) {\n        console.log(\"Error binding: \" + err);\n    } else {\n        console.log(\"Listening!\");\n    }\n});\n```\n\na corresponding client might look like:\n\n```javascript\nvar x = rpc.createTransport({ host: '127.0.0.1', port : 8000 });\nx.connect(function (err) {\n    if (err) {\n        console.log(\"error connecting\");\n    } else {\n        var c = new rpc.Client(x, \"myprog.1\");\n        c.invoke('add', { a : 5, b : 4}, function(err, response) {\n            if (err) {\n                console.log(\"error in RPC: \" + err);\n            } else { \n                assert.equal(9, response);\n            }\n            x.close();\n        });\n    }\n});\n```\n\nOr, equivalently, in beautiful \n[IcedCoffeeScript](https://github.com/maxtaco/coffee-script):\n\n```coffee\nx = rpc.createTransport { host: '127.0.0.1', port : 8000 }\nawait x.connect defer err\nif err\n    console.log \"error connecting\"\nelse\n    c = new rpc.Client x, \"myprog.1\"\n    await c.invoke 'add', { a : 5, b : 4}, defer err, response\n    if err? then console.log \"error in RPC: #{err}\"\n    else assert.equal 9, response\n    x.close()\n```\n\n## Installation\n\nIt should work to just install with npm:\n   \n    npm install -g framed-msgpack-rpc\n\nIf you install by hand, you will need to install the one dependency,\nwhich is the [the Purepack Msgpack library](http://github.com/maxtaco/purepack),\navailable as `purepack` on npm:\n\n    npm install -g purepack\n\n\n## Full API Documentation\n\nIf you are building real applications, it's good to look deeper than\nthe simple API introduced above. The full library is based on an\nabstraction called an FMPRPC *Transport*.  This class represents a\nstream of FMPRPC packets.  Clients and servers are built on top of\nthese streams, but not in one-to-one correspondence.  That is, several\nclients and several servers can share the same Transport object. Thus,\nFMPRPC supports multiplexing of many logically separated\napplication-level streams over the same underlying TCP stream.\n\n### Transports\n\nThe transport mechanics are available via the submodule `transport`:\n\n```javascript\nvar rpc = require('framed-msgpack-rpc');\nvar transport = rpc.transport;\n```\n\nTransports are auto-allocated in the case of servers (as part of the listen\nand connect process), but for clients, you'll find yourself allocating and\nconnecting them explicitly.\n\nAll transports are *stream transports* and for now are built atop TCP\nstreams.  Eventually we'll roll out support for Unix domain sockets, but there\nis no plan for UDP support right now.\n\n#### transport.Transport\n\n```javascript\nvar x = new transport.Transport(opts);\n```\nMake a new TCP transport, where `opts` are:\n\n* `port` - the port to connect to\n* `host` - the host to connect to, or `localhost` if none was given\n* `path` - the path to connect to, if using Unix domain sockets\n* `tcp_opts` - TCP options to pass to node's `net.connect` method, which \n is `{}` by default\n* `log_obj` - An object to use to log info, warnings, and errors on this \n transport.  By default, the default logging to `console.log` will be used.\n See *Logging* below.\n* `do_tcp_delay` - By default, the `Transport` will `setNoDelay` on\n TCP streams, but if you specify this flag as true, that behavior will\n be suppressed.\n* `hooks` - Hooks to be called on connection error and EOF. Especially\n useful for `RobustTransport`s (see below).  The known hooks are\n    * `hooks.connected` - Called when a transport is connected\n    * `hooks.eof` - Called when a transport hits EOF.\n* `dbgr` - A debugging object.  If set, it will turn on RPC tracing\n via the given debugging object. See _Debugging_ below.  I would have liked\n to call this a `debugger`, but that's a reserved keyword in node.\n \n\nThe following two options are used internally by `Server` and `Listener`\nclasses, and should not be accessed directly:\n* `tcp_stream` - Wrap an existing TCP stream \n* `parent` - A parent listener object\n\n#### transport.RobustTransport\n\n```javascript\nvar x = new transport.RobustTransport(opts, ropts);\n```\n\nA subclass of the above; with some more features:\n\n* If disconnected, will attempt to reconnect until successful.\n* Will queue calls issued in between a disconnect and a reconnect.\n* Will warn of RPCs that are outstanding for more than the given\n threshholds.\n\nThe `opts` dictionary is as in `Transport`, but there are additional\noptions that can be specified via `ropts`:\n\n* `reconnect_delay` - a float - the number of seconds to wait between\n connection attempts.\n* `queue_max` - the maximum number of RPCs to queue while reconnecting\n* `warn_threshhold` - RPCs that take more than this number of seconds\n are warned about via the logging object.\n* `error_threshhold` - RPCs that take more than this number of seconds\n are errored about via the logging object. Also, a timer will be set\n up to warn after this many seconds if the RPC isn't completed in time,\n while the RPC is still outstanding.\n\n#### transport.Transport.connect\n\n```javascript\nx.connect(function (err) { if (!err) { console.log(\"connected!\") } });\n```\n\nConnect a transport if it's not already connected. Takes a single callback,\nwhich takes one parameter --- an error that's null in the case of a \nsuccess, and non-null otherwise. In the case of a `RobustTransport`, the\ncallback will be fired after the initial connection attempt, but will continue\nto reconnect in the background. Additional error and warnings are issued\nvia the logger object, and an `info` is issued when a connection succeeds.\nAlso, if a `hooks.connected` was passed, it will be called on a successful\nconnection, both the first time, and after any subsequent reconnect.\n\n#### transport.Transport.is_connected\n\n```javascript\nvar b = x.is_connected();\n```\n\nReturns a bool, which is `true` if the transport is currently connected,\nand `false` otherwise.\n\n#### transport.Transport.close\n\n```javascript\nx.close()\n```\n\nCall to actively close the given connection.  It will trigger all of the\nregular hooks and warnings that an implicit close would.  In the case\nof a `RobustTransport`, the transport will not attempt a reconnection.\n\n#### transport.Transport.remote_address\n\n```javascript\nvar ip = x.remote_address();\n```\n\nGet the IP address of the remote side of the connection.  Note that this\ncan change for a RobustTransport, if the DNS resolution for the given\nhostname was updated and the connection was reestablished.  Will\nreturn a string in dotted-quad notation.\n\n#### transport.Transport.get_generation\n\n```javascript\nvar g = x.get_generation()\n```\n\nGet the generation number of this stream connection.  In the case of a\nregular Transport, it's always going to be 1.  In the case of a\n`RobustTransport`, this number is incremented every time the\nconnection is reestablished.\n\n\n#### transport.Transport.get_logger\n\n```javascript\nvar l = x.get_logger()\n```\n\nIf you want to grab to the logger on the given transport, use this\nmethod.  For instance, you can change the verbosity level with\n`x.get_logger().set_level(2)` if you are using the standard logging\nobject.\n\n#### transport.Transport.set_logger\n\n```javascript\nx.set_logger(new logger.Logger({prefix : \">\", level : logger.WARN}));\n```\n\nSet the logger object on this Transport to be the passed logger. \nYou can pass a subclass of the given `Logger` class if you need\ncustom behavior to fit in with your logging system.\n\n#### transport.Transport.set_debugger\n\n```javascript\nx.set_debugger(obj)\n```\n\nSet a debugging object on a transport.  After this is done, the core\nwill report that an RPC call was made or answered, either on the\nserver or client. See *Debugging* below for more details.\n\n#### transport.Transport.set_debug_flags\n\n```javascript\nx.set_debug_flags(flags)\n```\n\nCall `set_debugger` as above but with an object that will be allocated.\nThe object is of type `debug.Debugger`, and is initialized with flags\ngiven by `flags`. All debug traces are set to transport's logger object\nat the `log.levels.DEBUG` level.\n\nThese flags can either be in numerical form (e.g., `0xfff` ) or string\nliteral form (e.g., `\"a1m\"`).  If in the latter form, the flags will\nbe converted into the numerical form via `sflags_to_flags`.\n\n#### transport.createTransport or rpc.createTransport\n\n```javascript\nvar x = rpc.createTransport(opts)\n```\n\nCreate either a new `Transport` or `RobustTransport` with just one call.\nThe `opts` array is as above, but with a few differences.  First, the\n`opts` here is the merge of the `opts` and `ropts` above for the case\nof `RobustTransport`s; and second, an option of `robust : true` will\nenable the robust variety of the transport.\n\nNote that by default, I like function to use underscores rather than\ncamel case, but there's a lot of functions like `createConnection` \nin the standard library, so this particular function is in camel\ncase.  Sorry for the inconsistency.\n\n### Clients\n\n`Clients` are thin wrappers around `Transports`, allowing RPC client\ncalls.  Several clients can share the same Transport.  Import the\nclient libraries as a submodule:\n\n```javascript\nvar client = require('framed-msgpack-rpc').client;\n```\n\nThe API is as follows:\n\n#### client.Client\n\nMake a new RPC client:\n\n```\nvar c = new client.Client(x, prog);\n```\n\nWhere `x` is a `transport.Transport` and `prog` is the name of an RPC\nprogram.  Examples for `prog` are of the form `myprog.1`, meaning the\nprogram is called `myprog` and the version is 1.\n\nGiven a client, you can now make RPC calls over the specified connection:\n\n#### client.Client.invoke\n\nUse a Client to invoke an RPC as follows:\n\n```javscript\nc.invoke(proc, arg, function(err, res) {});\n```\n\nThe parameters are:\n\n* proc - The name of the RPC procedure.  It is joined with the\n RPC `program.version` specified when the client was allocated, yielding\n a dotted triple that's sent over the wire.\n* arg - A JSON object that's the argument to the RPC.\n* cb - A callback that's fired once there is a reply to the RPC. `err`\nis `null` in the success case, and non-null otherwise.  The `res` object is\noptionally returned in a success case, giving the reply to the RPC.  If\nthe server supplied a `null` result, then `res` can still be `null` in\nthe case of success.\n\n#### client.Client.notify\n\nAs above, but don't wait for a reply:\n\n```javscript\nc.notify(proc, arg);\n```\n\nHere, there is no callback, and no way to check if the sever received\nthe message (or got an error).  Notifying seems weird to me, but it\nwas in the original MsgpackRpc system, so it's reproduced here.\n\n### Servers\n\nTo write a server, the programmer must specify a series of *hooks*\nthat handle individual RPCs.  There are a few ways to achieve these\nends with this library.  The big difference is what is the `this`\nobject for the hook.  In the case of the `server.Server` and\n`server.SimpleServer` classes, the `this` object is the server itself.\nIn the `server.ContextualServer` class, the `this` object is a\nper-connection context object.  The first two are good for most cases.\n\nYou can get the server library through the submodule server:\n\n```javascript\nvar server = require('framed-msgpack-rpc').server;\n```\n\nBut most of the classes are also rexported from the top-level module.\n\n#### server.Server\n\nCreate a new server object; specify a port to bind to, a host IP\naddress to bind to, and also a set of RPC handlers.\n\n```javascript\nvar s = new server.Server(opts);\n```\n\nFor `opts`, the fields are:\n\n* `port` - A port to bind to\n* `host` - A host IP to bind to\n* `path` - A socket path to bind to, if being run on as Unix domain socket.\n* `TransportClass` - A transport class to use when allocating a new\n Transport for an incoming connection.  By default, it's `transport.Transport`\n* `log_obj` - A log object to log errors, and also to assign to \n  (via `make_child`) to child connections. Use the default log class\n  (which logs to `console.log`) if unspecified.\n* `programs` - Programs to support, following this JSON schema:\n\n```javascript\n{\n    prog_1 : {\n        proc_1 : function (arg, res, x) { /* ... */ },\n        proc_2 : function (arg, res, x) { /* ... */ },\n        /* etc ... */\n    },\n    prog_2 : {\n        proc_1 : function (arg, res, x) { /* ... */ }\n    }\n}\n```\n\nEach hook in the object is called once per RPC.  The `arg` argument is\nthe argument specified by the remote client.  The `res` argument is\nwhat the hook should call to send its reply to the client (by calling\n`res.result(some_object)`).  A server can also reject the RPC via\n`res.error(some_error_string)`).  The final argument, `x`, is the\ntransport over which the RPC came in to the server.  For instance, the\nserver can call `x.remote_address()` to figure out who the remote\nclient is.\n\n#### server.SimpleServer\n\nA `SimpleServer` behaves like a `Server` but is simplified in some\nways.  First off, it only handles one program, which is typically\nset on object construction.  Second off, it depends on inheritance;\nI've used CoffeeScript here, but you can use hand-rolled JavaScript\nstyle inheritance too. Finally, it infers your method hooks: on\nconstruction, it iterates over all methods in the current object,\nand infers that a hook of the form `h_foo` handles the RPC `foo`.\n\nHere's an example:\n\n```coffeescript\nclass MyServer extends server.SimpleServer\n\n  constructor : (d) ->\n    super d \n    @set_program_name \"myprog.1\"\n\n  h_reflect : (arg, res, x) -> res.result arg\n  h_null    : (arg, res, x) -> res.result null\n  h_add     : (arg, res, x) -> res.result { sum : arg.x + arg.y }\n```\n\nMost methods below are good for both `SimpleServer` and `Server`.\nThe former has a few extra; see the code in [server.iced](https://github.com/maxtaco/node-framed-msgpack-rpc/blob/master/src/server.iced).\n\n#### server.ContextualServer\n\nHere's an example:\n\n```coffeescript\nclass Prog1 extends server.Handler\n  h_foo : (arg, res) -> \n    console.log \"RPC to foo() from #{@transport.remote_address()}\"\n    res.result { y : arg.i + 2 }\n  h_bar : (arg, res) -> res.result { y : arg.j * arg.k }\n\nclass Prog2 extends server.Handler\n  h_foo : (arg, res) -> res.error \"not yet implemented\"\n  h_bar : (arg, res) -> res.error \"not yet implemented\"\n\ns = new server.ContextualServer \n   port : 8881 \n   classes : \n     \"prog.1\" : Prog1\n     \"prog.2\" : Prog2\n        \nawait s.listen defer err\nconsole.log \"Error: #{err}\" if err?\n```\n\nThis code constructs a `server.ContextualServer` with a `classes`\nobject that maps program names to classes. Whenever a new connection\nis established in the above example, a new `Prog1` object and a new\n`Prog2` object is created.  The former will handle all RPCs to\n`prog.1` on that connection; the latter will handle all RPCs to\n`prog.2`. Note that the `this` object here is per-connection, not\nper-server.  This allows you to store all sorts of interesting\nper-connection state. For more info, please see\n[server.iced](https://github.com/maxtaco/node-framed-msgpack-rpc/blob/master/src/server.iced).\n\n#### server.Server.listen\n\nBind to a port, and listen for incoming connections\n\n```javascript\ns.listen(function(err) {});\n```\n\nOn success, the callback is fired with `null`, and otherwise,\nan error object is passed.\n\n#### server.Server.listen_retry\n\nAs above, but keep retrying if binding failed:\n\n```javascript\ns.listen_retry(delay, function(err) {});\n```\n\nThe retry happens every `delay` seconds.  The given function is called\nback with `null` once the reconnection happens, or with the actual\nerror if it was other than `err.code = 'EADDRINUSE'`.\n\n#### server.Server.close\n\nClose a server, and give back its port to the OS.\n\n#### server.Server.set_port\n\nBefore calling `listen`, you can use this method to set the port\nthat the `Server` is going to bind to.\n\n#### server.Server.walk_children\n\nWalk the list of children, calling the specified function on each\nchild connection in the list:\n\n```javascript\ns.walk_children (function(ch) {});\n```\n\n### Logging Hooks\n\nAs you could imagine, an RPC can generate a lot of errors, warnings, and\ninformational messages.  Examples include: unmarshalling failures, \nunexpected EOFs, connection breaking, unhandled RPCs, etc. \n\nThis package has an extensible logging system to fit in with your \napplication, and a default logging system that should work for a lot\nof cases too.\n\nThe basic classes can be found in the `log` submodule, accessible as:\n\n```javascript\nvar log = require('framed-msgpack-rpc').log;\n```\n\nWhen a new `Listener` or `Transport` class is instantiated, it will\nneed a new logger object (note that `Listener` is the base class for the\nvarious `Server` classes).  It will try the following steps to pick a\n`log.Logger` object:\n\n1. Access the `opt.log_obj` passed to the `Transport` or `Listener` \n  constructor.  This is often times an object of a custom subclass\n  of `log.Logger`.\n1. If that is was not specified, allocate a new `log.Logger` object:\n     1. If `log.set_default_logger_class` was previous called, allocate\n        one of those objects.\n     1. Otherwise, allocate a `log.Logger` object.\n\nOnce this `log.Logger` object is allocated, the `Transport` or\n`Listener` class will call `set_remote` on it, so that subsequent log\nlines will show which client or server generated the message.\n\nLogging is via the following methods, in ascending order of severity:\n\n```javascript\nlog.Logger.debug(msg)\nlog.Logger.info(msg)\nlog.Logger.warn(msg)\nlog.Logger.error(msg)\nlog.Logger.fatal(msg)\n```\n\nThey all, by default, write the message `msg` to `console.log` while\nprepending the `remote_address` supplied above.  The default log level\nis set to `log.levels.INFO`, but you can set it to `log.levels.WARN`,\n`log.levels.ERRORS`, etc.  Warnings at lower levels will be silently\nswallowed.  For the default logger object, the method\n`log.Logger.set_level` can be used to set the logging level as desired.\n\nTo make a custom logger class, you can subclass `log.Logger`, or use\nduck-typing: just make sure your class implements `set_remote` and the\nfive leveled logging methods above.\n\nSee `VLogger` in `test/all.iced` for one example of a different logger\n--- it's used to make the regression tests look pretty.\n\nSee [log.iced](https://github.com/maxtaco/node-framed-msgpack-rpc/blob/master/src/log.iced) for more details.\n\n### Debugging and Tracing\n\nAn debugger is a JavaScript object that is passed into the FMPRPC core,\nand if available, is used to dump RPC debug traces. These debuggers can\nbe installed when a `Transport` is allocated, by specifying the\n`opts.dbgr` option, or by calling `set_debugger` on most\nFMPRPC objects.\n\nIf a debugging object is active, it is `call`ed with `debug.Message`\nobject when an RPC comes in or goes out.  The `debug.Message` object\ncontains a bunch of fields:\n\n```coffeescript\nF =\n  METHOD : 0x1\n  REMOTE : 0x2\n  SEQID : 0x4\n  TIMESTAMP : 0x8\n  ERR : 0x10  \n  ARG : 0x20\n  RES : 0x40\n  TYPE : 0x80\n  DIR : 0x100          # which direction -- incoming or outgoing?\n```\n\nDebugging objects can choose to spam some or all of these fields,\ndepending on how bad the bug is.  For most purposes, the supplied\n`debug.Debugger` makes a nice debugger object that you can easily tune\nto print only the fields of your choosing (via the `flags` parameter).\n\nSee [debug.iced](https://github.com/maxtaco/node-framed-msgpack-rpc/blob/master/src/debug.iced) for more details.\n\n## Internals\n\n### Packetizer\n\nTo come. See [packetizer.iced](https://github.com/maxtaco/node-framed-msgpack-rpc/blob/master/src/packetizer.iced) for details.\n\n### Dispatch\n\nTo come. See [dispatch.iced](https://github.com/maxtaco/node-framed-msgpack-rpc/blob/master/src/dispatch.iced) for details.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/maxtaco/node-framed-msgpack-rpc/issues"
  },
  "_id": "framed-msgpack-rpc@1.1.3",
  "_shasum": "c83108b6832f864f725ebe95f902d77dee7bf68d",
  "_from": "framed-msgpack-rpc@1.1.3",
  "_resolved": "https://registry.npmjs.org/framed-msgpack-rpc/-/framed-msgpack-rpc-1.1.3.tgz"
}
