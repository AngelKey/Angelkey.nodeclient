// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var ASP, C, Engine, K, KeyBlock, KeyManager, Lifespan, Message, P3SKB, PgpEngine, Primary, RSA, Subkey, assert_no_nulls, box, bufeq_secure, bufferify, decode, encode, iced, katch, make_esc, opkts, ops_to_keyflags, parse, read_base64, unbox, unix_time, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  RSA = require('./rsa').RSA;

  K = require('./const').kb;

  C = require('./const').openpgp;

  make_esc = require('iced-error').make_esc;

  _ref = require('./util'), assert_no_nulls = _ref.assert_no_nulls, ASP = _ref.ASP, katch = _ref.katch, bufeq_secure = _ref.bufeq_secure, unix_time = _ref.unix_time, bufferify = _ref.bufferify;

  ops_to_keyflags = require('./openpgp/util').ops_to_keyflags;

  _ref1 = require('./keywrapper'), Lifespan = _ref1.Lifespan, Subkey = _ref1.Subkey, Primary = _ref1.Primary;

  _ref2 = require('./openpgp/armor'), Message = _ref2.Message, encode = _ref2.encode, decode = _ref2.decode;

  parse = require('./openpgp/parser').parse;

  KeyBlock = require('./openpgp/processor').KeyBlock;

  opkts = require('./openpgp/packet/all');

  _ref3 = require('./keybase/encode'), read_base64 = _ref3.read_base64, box = _ref3.box, unbox = _ref3.unbox, box = _ref3.box;

  P3SKB = require('./keybase/packet/p3skb').P3SKB;

  Engine = (function() {
    function Engine(_arg) {
      var k, _i, _len, _ref4;
      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids;
      this.packets = [];
      this.messages = [];
      this._allocate_key_packets();
      _ref4 = this.subkeys;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        k.primary = this.primary;
      }
      this._index_keys();
      true;
    }

    Engine.prototype._index_keys = function() {
      var k, _i, _len, _ref4, _results;
      this._index = {};
      _ref4 = this._all_keys();
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        _results.push(this._index[this.ekid(k)] = k);
      }
      return _results;
    };

    Engine.prototype.ekid = function(k) {
      return this.key(k).ekid();
    };

    Engine.prototype._allocate_key_packets = function() {
      var key, _i, _len, _ref4, _results;
      this._v_allocate_key_packet(this.primary, {
        subkey: false
      });
      _ref4 = this.subkeys;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        key = _ref4[_i];
        _results.push(this._v_allocate_key_packet(key, {
          subkey: true
        }));
      }
      return _results;
    };

    Engine.prototype._all_keys = function() {
      return [this.primary].concat(this.subkeys);
    };

    Engine.prototype.self_sign_primary = function(args, cb) {
      return this._v_self_sign_primary(args, cb);
    };

    Engine.prototype.get_all_key_materials = function() {
      var k;
      return [[this.key(this.primary), true]].concat((function() {
        var _i, _len, _ref4, _results;
        _ref4 = this.subkeys;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          k = _ref4[_i];
          _results.push([this.key(k), false]);
        }
        return _results;
      }).call(this));
    };

    Engine.prototype.sign_subkeys = function(_arg, cb) {
      var asp, err, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      err = null;
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref4, _results, _while;
          _ref4 = _this.subkeys;
          _len = _ref4.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              subkey = _ref4[_i];
              if (err == null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                    funcname: "Engine.sign_subkeys"
                  });
                  _this._v_sign_subkey({
                    asp: asp,
                    subkey: subkey
                  }, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 68
                  }));
                  __iced_deferrals._fulfill();
                })(_next);
              } else {
                return _continue();
              }
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    Engine.prototype.get_subkey_materials = function() {
      var k, _i, _len, _ref4, _results;
      _ref4 = this.subkeys;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        _results.push(this.key(k));
      }
      return _results;
    };

    Engine.prototype.is_locked = function() {
      var i, k, _i, _len, _ref4;
      _ref4 = this._all_keys();
      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
        k = _ref4[i];
        if (this.key(k).is_locked()) {
          return true;
        }
      }
      return false;
    };

    Engine.prototype.has_private = function() {
      var k, _i, _len, _ref4;
      _ref4 = this._all_keys();
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        if (this.key(k).has_private()) {
          return true;
        }
      }
      return false;
    };

    Engine.prototype.sign = function(_arg, cb) {
      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "Engine.sign"
          });
          _this.self_sign_primary({
            asp: asp
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 92
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (typeof err === "undefined" || err === null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                  funcname: "Engine.sign"
                });
                _this.sign_subkeys({
                  asp: asp
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 93
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(err);
          });
        };
      })(this));
    };

    Engine.prototype.check_eq = function(eng2) {
      var err, i, key, _i, _len, _ref4;
      err = null;
      if (!this.primary.key.eq(eng2.primary.key)) {
        err = new Error("Primary keys don't match");
      } else if (this.subkeys.length !== eng2.subkeys.length) {
        err = new Error("different # of subkeys");
      } else {
        _ref4 = this.subkeys;
        for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
          key = _ref4[i];
          if (this.err == null) {
            if (!key.key.eq(eng2.subkeys[i].key)) {
              err = new Error("subkey " + i + " doesn't match");
            }
          }
        }
      }
      return err;
    };

    Engine.prototype.merge_private = function(eng2) {
      var err, i, k, _i, _len, _ref4;
      err = this._merge_private_primary(eng2);
      if (err == null) {
        _ref4 = eng2.subkeys;
        for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
          k = _ref4[i];
          if ((err = this._merge_private_subkey(k, i)) != null) {
            break;
          }
        }
      }
      return err;
    };

    Engine.prototype._merge_private_primary = function(eng2) {
      var err;
      err = !this.key(eng2.primary).has_secret_key_material() ? null : this._merge_1_private(this.primary, eng2.primary) ? null : new Error("primary public key doesn't match private key");
      return err;
    };

    Engine.prototype._merge_private_subkey = function(k2, i) {
      var ekid, err, k;
      err = !this.key(k2).has_secret_key_material() ? null : (ekid = this.ekid(k2)) == null ? new Error("Subkey " + i + " is malformed") : (k = this._index[ekid]) == null ? new Error("Subkey " + i + " wasn't found in public key") : this._merge_1_private(k, k2) ? null : new Error("subkey " + i + " can't be merged");
      return err;
    };

    Engine.prototype.unlock_keys = function(_arg, cb) {
      var asp, esc, i, passphrase, subkey, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, passphrase = _arg.passphrase, tsenc = _arg.tsenc;
      esc = make_esc(cb, "Engine::unlock_keys");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "Engine.unlock_keys"
          });
          _this.key(_this.primary).unlock({
            asp: asp,
            tsenc: tsenc,
            passphrase: passphrase
          }, esc(__iced_deferrals.defer({
            lineno: 141
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            var _i, _len, _ref4, _results, _while;
            _ref4 = _this.subkeys;
            _len = _ref4.length;
            i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(i < _len)) {
                return _break();
              } else {
                subkey = _ref4[i];
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                    funcname: "Engine.unlock_keys"
                  });
                  _this.key(subkey).unlock({
                    asp: asp,
                    tsenc: tsenc,
                    passphrase: passphrase
                  }, esc(__iced_deferrals.defer({
                    lineno: 143
                  })));
                  __iced_deferrals._fulfill();
                })(_next);
              }
            };
            _while(__iced_k);
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    Engine.prototype.export_keys_to_keyring = function(km) {
      var k, x;
      x = (function(_this) {
        return function(key_wrapper, is_primary) {
          return {
            km: km,
            is_primary: is_primary,
            key_wrapper: key_wrapper,
            key_material: _this.key(key_wrapper),
            key: _this.key(key_wrapper).key
          };
        };
      })(this);
      return [x(this.primary, true)].concat((function() {
        var _i, _len, _ref4, _results;
        _ref4 = this.subkeys;
        _results = [];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          k = _ref4[_i];
          _results.push(x(k, false));
        }
        return _results;
      }).call(this));
    };

    Engine.prototype._merge_1_private = function(k1, k2) {
      if (bufeq_secure(this.ekid(k1), this.ekid(k2))) {
        this.key(k1).merge_private(this.key(k2));
        return true;
      } else {
        return false;
      }
    };

    return Engine;

  })();

  PgpEngine = (function(_super) {
    __extends(PgpEngine, _super);

    function PgpEngine(_arg) {
      var primary, subkeys, userids;
      primary = _arg.primary, subkeys = _arg.subkeys, userids = _arg.userids, this.user_attributes = _arg.user_attributes;
      PgpEngine.__super__.constructor.call(this, {
        primary: primary,
        subkeys: subkeys,
        userids: userids
      });
    }

    PgpEngine.prototype.key = function(k) {
      return k._pgp;
    };

    PgpEngine.prototype._v_allocate_key_packet = function(key, opts) {
      if (key._pgp == null) {
        return key._pgp = new opkts.KeyMaterial({
          key: key.key,
          timestamp: key.lifespan.generated,
          flags: key.flags,
          opts: opts
        });
      }
    };

    PgpEngine.prototype._v_self_sign_primary = function(_arg, cb) {
      var asp, err, raw_payload, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, raw_payload = _arg.raw_payload;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "PgpEngine._v_self_sign_primary"
          });
          _this.key(_this.primary).self_sign_key({
            lifespan: _this.primary.lifespan,
            userids: _this.userids,
            raw_payload: raw_payload
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return sigs = arguments[1];
              };
            })(),
            lineno: 188
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, sigs);
        };
      })(this));
    };

    PgpEngine.prototype._v_sign_subkey = function(_arg, cb) {
      var asp, err, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, subkey = _arg.subkey;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "PgpEngine._v_sign_subkey"
          });
          _this.key(_this.primary).sign_subkey({
            subkey: _this.key(subkey),
            lifespan: subkey.lifespan
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 194
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    PgpEngine.prototype.set_passphrase = function(pp) {
      var k, _i, _len, _ref4, _results;
      this.primary.passphrase = pp;
      _ref4 = this.subkeys;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        _results.push(k.passphrase = pp);
      }
      return _results;
    };

    PgpEngine.prototype._export_keys_to_binary = function(opts) {
      var packets, subkey, userid, _i, _j, _len, _len1, _ref4, _ref5;
      packets = [this.key(this.primary).export_framed(opts)];
      _ref4 = this.userids;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        userid = _ref4[_i];
        packets.push(userid.write(), userid.get_framed_signature_output());
      }
      opts.subkey = true;
      _ref5 = this.subkeys;
      for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
        subkey = _ref5[_j];
        packets.push(this.key(subkey).export_framed(opts), this.key(subkey).get_subkey_binding_signature_output());
      }
      assert_no_nulls(packets);
      return Buffer.concat(packets);
    };

    PgpEngine.prototype.export_keys = function(opts) {
      var msg, mt, type;
      mt = C.message_types;
      type = opts["private"] ? mt.private_key : mt.public_key;
      msg = this._export_keys_to_binary(opts);
      return encode(type, msg);
    };

    PgpEngine.prototype.export_to_p3skb = function() {
      var priv_clear, pub;
      pub = this._export_keys_to_binary({
        "private": false
      });
      priv_clear = this._export_keys_to_binary({
        "private": true
      });
      return new P3SKB({
        pub: pub,
        priv_clear: priv_clear
      });
    };

    PgpEngine.prototype.find_key = function(key_id) {
      var k, _i, _len, _ref4;
      _ref4 = this._all_keys();
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        if (bufeq_secure(this.key(k).get_key_id(), key_id)) {
          return k;
        }
      }
      return null;
    };

    PgpEngine.prototype.get_key_id = function() {
      return this.key(this.primary).get_key_id();
    };

    PgpEngine.prototype.get_short_key_id = function() {
      return this.key(this.primary).get_short_key_id();
    };

    PgpEngine.prototype.get_fingerprint = function() {
      return this.key(this.primary).get_fingerprint();
    };

    PgpEngine.prototype.find_best_key = function(flags, need_priv) {
      var check, k, wrapper, _i, _len, _ref4;
      if (need_priv == null) {
        need_priv = false;
      }
      wrapper = null;
      check = (function(_this) {
        return function(k) {
          var km, ok1, ok2;
          km = _this.key(k);
          ok1 = km.fulfills_flags(flags) || ((k.flags & flags) === flags);
          ok2 = !need_priv || km.has_private();
          return ok1 && ok2;
        };
      })(this);
      _ref4 = this.subkeys;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        if (wrapper == null) {
          if (check(k)) {
            wrapper = k;
          }
        }
      }
      if ((wrapper == null) && check(this.primary)) {
        wrapper = this.primary;
      }
      return (wrapper != null ? this.key(wrapper) : null);
    };

    PgpEngine.prototype.fetch = function(key_ids, op_mask, cb) {
      var err, flags, i, key, kid, ret_i, _i, _len;
      flags = ops_to_keyflags(op_mask);
      err = key = null;
      key = null;
      ret_i = null;
      for (i = _i = 0, _len = key_ids.length; _i < _len; i = ++_i) {
        kid = key_ids[i];
        if (!(key == null)) {
          continue;
        }
        key = this.find_key(kid);
        if (key != null) {
          ret_i = i;
        }
      }
      err = !key ? new Error("No keys match the given fingerprint") : !this.key(key).fulfills_flags(flags) ? new Error("We don't have a key for the requested PGP ops") : void 0;
      return cb(err, key, ret_i);
    };

    return PgpEngine;

  })(Engine);

  KeyManager = (function() {
    function KeyManager(_arg) {
      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public, this.armored_pgp_private = _arg.armored_pgp_private, this.user_attributes = _arg.user_attributes;
      this.pgp = new PgpEngine({
        primary: this.primary,
        subkeys: this.subkeys,
        userids: this.userids,
        user_attributes: this.user_attributes
      });
      this.engines = [this.pgp];
      this._signed = false;
      this.p3skb = null;
    }

    KeyManager.generate = function(_arg, cb) {
      var F, KEY_FLAGS_PRIMARY, KEY_FLAGS_STD, asp, bundle, esc, expire_in, flags, gen, generated, i, nbits, nsubs, primary, primary_flags, s, sub_flags, subkey, subkeys, subkeys_out, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _len;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, userid = _arg.userid, primary = _arg.primary, subkeys = _arg.subkeys, sub_flags = _arg.sub_flags, nsubs = _arg.nsubs, primary_flags = _arg.primary_flags, nbits = _arg.nbits, expire_in = _arg.expire_in;
      asp = ASP.make(asp);
      F = C.key_flags;
      KEY_FLAGS_STD = F.sign_data | F.encrypt_comm | F.encrypt_storage | F.auth;
      KEY_FLAGS_PRIMARY = KEY_FLAGS_STD | F.certify_keys;
      primary || (primary = {});
      primary.flags || (primary.flags = primary_flags || KEY_FLAGS_PRIMARY);
      primary.nbits || (primary.nbits = nbits || K.key_defaults.primary.nbits);
      primary.expire_in || (primary.expire_in = (expire_in != null ? expire_in.primary : void 0) || K.key_defaults.primary.expire_in);
      if ((nsubs != null) && (sub_flags == null)) {
        sub_flags = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= nsubs ? _i < nsubs : _i > nsubs; i = 0 <= nsubs ? ++_i : --_i) {
            _results.push(KEY_FLAGS_STD);
          }
          return _results;
        })();
      }
      subkeys || (subkeys = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = sub_flags.length; _i < _len; _i++) {
          flags = sub_flags[_i];
          _results.push({
            flags: flags
          });
        }
        return _results;
      })());
      for (_i = 0, _len = subkeys.length; _i < _len; _i++) {
        subkey = subkeys[_i];
        subkey.nbits || (subkey.nbits = nbits || K.key_defaults.sub.nbits);
        subkey.expire_in || (subkey.expire_in = (expire_in != null ? expire_in.subkey : void 0) || K.key_defaults.sub.expire_in);
        subkey.flags || (subkey.flags = KEY_FLAGS_STD);
      }
      userids = [new opkts.UserID(userid)];
      generated = unix_time();
      esc = make_esc(cb, "KeyManager::generate");
      gen = function(_arg1, cb) {
        var err, key, klass, lifespan, params, primary, section, wrapper, ___iced_passed_deferral1, __iced_deferrals, __iced_k;
        __iced_k = __iced_k_noop;
        ___iced_passed_deferral1 = iced.findDeferral(arguments);
        klass = _arg1.klass, section = _arg1.section, params = _arg1.params, primary = _arg1.primary;
        asp.section(section);
        (function(_this) {
          return (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral1,
              filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced"
            });
            RSA.generate({
              asp: asp,
              nbits: params.nbits
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return key = arguments[1];
                };
              })(),
              lineno: 354
            }));
            __iced_deferrals._fulfill();
          });
        })(this)((function(_this) {
          return function() {
            if (typeof err === "undefined" || err === null) {
              lifespan = new Lifespan({
                generated: generated,
                expire_in: params.expire_in
              });
              wrapper = new klass({
                key: key,
                lifespan: lifespan,
                flags: params.flags,
                primary: primary
              });
            }
            return cb(err, wrapper);
          };
        })(this));
      };
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "KeyManager.generate"
          });
          gen({
            klass: Primary,
            section: "primary",
            params: primary
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return primary = arguments[0];
              };
            })(),
            lineno: 360
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          subkeys_out = [];
          (function(__iced_k) {
            var _j, _len1, _ref4, _results, _while;
            _ref4 = subkeys;
            _len1 = _ref4.length;
            i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(i < _len1)) {
                return _break();
              } else {
                subkey = _ref4[i];
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                    funcname: "KeyManager.generate"
                  });
                  gen({
                    klass: Subkey,
                    section: "subkey " + (i + 1),
                    params: subkey,
                    primary: primary
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return s = arguments[0];
                      };
                    })(),
                    lineno: 363
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  return _next(subkeys_out.push(s));
                });
              }
            };
            _while(__iced_k);
          })(function() {
            bundle = new KeyManager({
              primary: primary,
              subkeys: subkeys_out,
              userids: userids
            });
            return cb(null, bundle);
          });
        };
      })(this));
    };

    KeyManager.prototype.set_enc = function(e) {
      return this.tsenc = e;
    };

    KeyManager.import_from_armored_pgp = function(_arg, cb) {
      var asp, err, msg, raw, ret, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4, _ref5;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      raw = _arg.raw, asp = _arg.asp;
      asp = ASP.make(asp);
      warnings = null;
      ret = null;
      _ref4 = decode(raw), err = _ref4[0], msg = _ref4[1];
      if (err == null) {
        if (!((_ref5 = msg.type) === C.message_types.public_key || _ref5 === C.message_types.private_key)) {
          err = new Error("Wanted a public or private key; got: " + msg.type);
        }
      }
      (function(_this) {
        return (function(__iced_k) {
          if (err == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                funcname: "KeyManager.import_from_armored_pgp"
              });
              KeyManager.import_from_pgp_message({
                msg: msg,
                asp: asp
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    ret = arguments[1];
                    return warnings = arguments[2];
                  };
                })(),
                lineno: 390
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, ret, warnings);
        };
      })(this));
    };

    KeyManager.import_from_p3skb = function(_arg, cb) {
      var asp, err, km, msg, p3skb, raw, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      raw = _arg.raw, asp = _arg.asp;
      asp = ASP.make(asp);
      km = null;
      warnings = null;
      _ref4 = katch(function() {
        return P3SKB.alloc(unbox(read_base64(raw)));
      }), err = _ref4[0], p3skb = _ref4[1];
      (function(_this) {
        return (function(__iced_k) {
          if (err == null) {
            msg = new Message({
              body: p3skb.pub,
              type: C.message_types.public_key
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                funcname: "KeyManager.import_from_p3skb"
              });
              KeyManager.import_from_pgp_message({
                msg: msg,
                asp: asp
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    km = arguments[1];
                    return warnings = arguments[2];
                  };
                })(),
                lineno: 403
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(km != null ? km.p3skb = p3skb : void 0);
            });
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, km, warnings);
        };
      })(this));
    };

    KeyManager.prototype.unlock_p3skb = function(_arg, cb) {
      var asp, err, km, msg, passphrase, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, tsenc = _arg.tsenc;
      asp = ASP.make(asp);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "KeyManager.unlock_p3skb"
          });
          _this.p3skb.unlock({
            tsenc: tsenc,
            asp: asp
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 411
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (err == null) {
              msg = new Message({
                body: _this.p3skb.priv.data,
                type: C.message_types.private_key
              });
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                  funcname: "KeyManager.unlock_p3skb"
                });
                KeyManager.import_from_pgp_message({
                  msg: msg,
                  asp: asp
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      err = arguments[0];
                      return km = arguments[1];
                    };
                  })(),
                  lineno: 414
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            if (typeof err === "undefined" || err === null) {
              err = _this.pgp.merge_private(km.pgp);
            }
            (function(__iced_k) {
              if (err == null) {
                passphrase = new Buffer([]);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                    funcname: "KeyManager.unlock_p3skb"
                  });
                  _this.unlock_pgp({
                    passphrase: passphrase
                  }, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 423
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              return cb(err);
            });
          });
        };
      })(this));
    };

    KeyManager.import_from_pgp_message = function(_arg, cb) {
      var asp, bundle, err, k, kb, msg, packets, warnings, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      msg = _arg.msg, asp = _arg.asp;
      asp = ASP.make(asp);
      bundle = null;
      warnings = null;
      if (typeof err === "undefined" || err === null) {
        _ref4 = parse(msg.body), err = _ref4[0], packets = _ref4[1];
      }
      (function(_this) {
        return (function(__iced_k) {
          if (err == null) {
            kb = new KeyBlock(packets);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                funcname: "KeyManager.import_from_pgp_message"
              });
              kb.process(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 438
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(warnings = kb.warnings);
            });
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          if (err == null) {
            bundle = new KeyManager({
              primary: KeyManager._wrap_pgp(Primary, kb.primary),
              subkeys: (function() {
                var _i, _len, _ref5, _results;
                _ref5 = kb.subkeys;
                _results = [];
                for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
                  k = _ref5[_i];
                  _results.push(KeyManager._wrap_pgp(Subkey, k));
                }
                return _results;
              })(),
              armored_pgp_public: msg.raw(),
              user_attributes: kb.user_attributes,
              userids: kb.userids
            });
          }
          return cb(err, bundle, warnings);
        };
      })(this));
    };

    KeyManager.prototype.merge_pgp_private = function(_arg, cb) {
      var asp, b2, err, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      raw = _arg.raw, asp = _arg.asp;
      asp = ASP.make(asp);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "KeyManager.merge_pgp_private"
          });
          KeyManager.import_from_armored_pgp({
            raw: raw,
            asp: asp
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return b2 = arguments[1];
              };
            })(),
            lineno: 456
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            err = _this.pgp.merge_private(b2.pgp);
          }
          return cb(err);
        };
      })(this));
    };

    KeyManager.prototype.check_pgp_public_eq = function(km2) {
      return this.pgp.check_eq(km2.pgp);
    };

    KeyManager.prototype.unlock_pgp = function(_arg, cb) {
      var err, passphrase, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      passphrase = _arg.passphrase;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "KeyManager.unlock_pgp"
          });
          _this.pgp.unlock_keys({
            passphrase: passphrase
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 470
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    KeyManager.prototype.is_pgp_locked = function() {
      return this.pgp.is_locked();
    };

    KeyManager.prototype.is_keybase_locked = function() {
      return this.keybase.is_locked();
    };

    KeyManager.prototype.has_pgp_private = function() {
      return this.pgp.has_private();
    };

    KeyManager.prototype.has_p3skb_private = function() {
      var _ref4;
      return (_ref4 = this.p3skb) != null ? _ref4.has_private() : void 0;
    };

    KeyManager.prototype.has_keybase_private = function() {
      return this.keybase.has_private();
    };

    KeyManager.prototype.is_p3skb_locked = function() {
      var _ref4;
      return (_ref4 = this.p3skb) != null ? _ref4.is_locked() : void 0;
    };

    KeyManager.prototype.unlock_keybase = function(_arg, cb) {
      var asp, err, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      tsenc = _arg.tsenc, asp = _arg.asp;
      asp = ASP.make(asp);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "KeyManager.unlock_keybase"
          });
          _this.keybase.unlock_keys({
            tsenc: tsenc,
            asp: asp
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 488
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    KeyManager.prototype.export_private_to_server = function(_arg, cb) {
      var asp, err, p3skb, ret, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      tsenc = _arg.tsenc, asp = _arg.asp;
      asp = ASP.make(asp);
      err = ret = null;
      (function(_this) {
        return (function(__iced_k) {
          if ((err = _this._assert_signed()) == null) {
            p3skb = _this.pgp.export_to_p3skb();
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                funcname: "KeyManager.export_private_to_server"
              });
              p3skb.lock({
                tsenc: tsenc,
                asp: asp
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 501
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          if (err == null) {
            ret = box(p3skb.frame_packet()).toString('base64');
          }
          return cb(err, ret);
        };
      })(this));
    };

    KeyManager.prototype.export_pgp_private_to_client = function(_arg, cb) {
      var asp, err, msg, passphrase, regen;
      passphrase = _arg.passphrase, asp = _arg.asp, regen = _arg.regen;
      asp = ASP.make(asp);
      err = msg = null;
      if (passphrase != null) {
        passphrase = bufferify(passphrase);
      }
      if ((regen == null) && (msg = this.armored_pgp_private)) {

      } else if ((err = this._assert_signed()) == null) {
        msg = this.pgp.export_keys({
          "private": true,
          passphrase: passphrase
        });
      }
      return cb(err, msg);
    };

    KeyManager.prototype.export_pgp_public = function(_arg, cb) {
      var asp, err, msg, regen;
      asp = _arg.asp, regen = _arg.regen;
      asp = ASP.make(asp);
      err = null;
      if ((err = this._assert_signed()) == null) {
        if (!regen) {
          msg = this.armored_pgp_public;
        }
        if (msg == null) {
          msg = this.pgp.export_keys({
            "private": false
          });
        }
      }
      return cb(err, msg);
    };

    KeyManager.prototype.sign_pgp = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
      return this.pgp.sign({
        asp: asp
      }, cb);
    };

    KeyManager.prototype.sign = function(_arg, cb) {
      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      asp = ASP.make(asp);
      asp.section("sign");
      asp.progress({
        what: "sign PGP",
        total: 1,
        i: 0
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
            funcname: "KeyManager.sign"
          });
          _this.sign_pgp({
            asp: asp
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 541
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          asp.progress({
            what: "sign PGP",
            total: 1,
            i: 1
          });
          if (typeof err === "undefined" || err === null) {
            _this._signed = true;
          }
          return cb(err);
        };
      })(this));
    };

    KeyManager.prototype.get_userids_mark_primary = function() {
      var do_insert, i, k, max, max_s, mymax, obj, pair, prev, primary_time, ret, s, tab, userid, _i, _len, _ref4;
      max = null;
      max_s = null;
      tab = {};
      mymax = function(a, b) {
        if ((a == null) && (b == null)) {
          return null;
        } else if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        } else if (a > b) {
          return a;
        } else {
          return b;
        }
      };
      _ref4 = this.userids;
      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
        userid = _ref4[i];
        if (!(userid != null)) {
          continue;
        }
        s = userid.utf8();
        pair = userid.time_primary_pair();
        obj = {
          userid: userid,
          pair: pair,
          i: i
        };
        do_insert = false;
        if ((prev = tab[s]) != null) {
          primary_time = mymax(prev.pair[1], pair[1]);
          if (!(prev.pair[0] != null) || (pair[0] && prev.pair[0] < pair[0])) {
            do_insert = true;
          }
        } else {
          primary_time = pair[1];
          do_insert = true;
        }
        if (do_insert) {
          tab[s] = obj;
        }
        if ((primary_time != null) && ((max == null) || max < primary_time)) {
          max_s = s;
          max = primary_time;
        }
      }
      if (max_s != null) {
        tab[max_s].userid.primary = true;
      }
      ret = [];
      for (k in tab) {
        obj = tab[k];
        obj.userid.most_recent_sig = obj.pair[0];
        ret.push(obj.userid);
      }
      return ret;
    };

    KeyManager.prototype.fetch = function(key_ids, flags, cb) {
      return this.pgp.fetch(key_ids, flags, cb);
    };

    KeyManager.prototype.find_pgp_key = function(key_id) {
      return this.pgp.find_key(key_id);
    };

    KeyManager.prototype.find_best_pgp_key = function(flags, need_priv) {
      return this.pgp.find_best_key(flags, need_priv);
    };

    KeyManager.prototype.find_signing_pgp_key = function() {
      return this.find_best_pgp_key(C.key_flags.sign_data, true);
    };

    KeyManager.prototype.find_crypt_pgp_key = function(need_priv) {
      if (need_priv == null) {
        need_priv = false;
      }
      return this.find_best_pgp_key(C.key_flags.encrypt_comm, need_priv);
    };

    KeyManager.prototype.get_primary_keypair = function() {
      return this.primary.key;
    };

    KeyManager.prototype.get_all_pgp_key_materials = function() {
      return this.pgp.get_all_key_materials();
    };

    KeyManager.prototype.export_pgp_keys_to_keyring = function() {
      return this.pgp.export_keys_to_keyring(this);
    };

    KeyManager.prototype.get_pgp_key_id = function() {
      return this.pgp.get_key_id();
    };

    KeyManager.prototype.get_pgp_short_key_id = function() {
      return this.pgp.get_short_key_id();
    };

    KeyManager.prototype.get_pgp_fingerprint = function() {
      return this.pgp.get_fingerprint();
    };

    KeyManager.prototype._apply_to_engines = function(_arg, cb) {
      var args, e, err, meth, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = _arg.args, meth = _arg.meth;
      err = null;
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref4, _results, _while;
          _ref4 = _this.engines;
          _len = _ref4.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              e = _ref4[_i];
              if (!err) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/max/src/keybase/kbpgp/src/keymanager.iced",
                    funcname: "KeyManager._apply_to_engines"
                  });
                  meth.call(e, args, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 633
                  }));
                  __iced_deferrals._fulfill();
                })(_next);
              } else {
                return _continue();
              }
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    KeyManager.prototype._assert_signed = function() {
      if (this._signed) {
        return null;
      } else {
        return new Error("need to sign before export");
      }
    };

    KeyManager._wrap_pgp = function(klass, kmp) {
      return new klass({
        key: kmp.key,
        lifespan: new Lifespan({
          generated: kmp.timestamp
        }),
        _pgp: kmp
      });
    };

    return KeyManager;

  })();

  exports.KeyManager = KeyManager;

  exports.opkts = opkts;

}).call(this);
