// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var BaseKey, BaseKeyPair, C, K, SHA512, bn, bufeq_secure, konst;

  konst = require('./const');

  C = konst.openpgp;

  K = konst.kb;

  SHA512 = require('./hash').SHA512;

  bn = require('./bn');

  bufeq_secure = require('pgp-utils').util.bufeq_secure;

  exports.BaseKey = BaseKey = (function() {
    function BaseKey() {}

    BaseKey.alloc = function(klass, raw, d) {
      var err, o, orig_len, _i, _len, _ref, _ref1;
      if (d == null) {
        d = {};
      }
      orig_len = raw.length;
      err = null;
      _ref = klass.ORDER;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        o = _ref[_i];
        if (err == null) {
          _ref1 = bn.mpi_from_buffer(raw), err = _ref1[0], d[o] = _ref1[1], raw = _ref1[2];
        }
      }
      if (err) {
        return [err, null];
      } else {
        return [null, new klass(d), orig_len - raw.length];
      }
    };

    BaseKey.prototype.serialize = function() {
      var e;
      return Buffer.concat((function() {
        var _i, _len, _ref, _results;
        _ref = this.ORDER;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          _results.push(this[e].to_mpi_buffer());
        }
        return _results;
      }).call(this));
    };

    return BaseKey;

  })();

  exports.BaseKeyPair = BaseKeyPair = (function() {
    function BaseKeyPair(_arg) {
      this.priv = _arg.priv, this.pub = _arg.pub;
      this.pub.parent = this;
      if (this.priv != null) {
        this.priv.parent = this;
      }
    }

    BaseKeyPair.prototype.serialize = function() {
      return this.pub.serialize();
    };

    BaseKeyPair.prototype.hash = function() {
      return SHA512(this.serialize());
    };

    BaseKeyPair.prototype.ekid = function() {
      return Buffer.concat([new Buffer([K.kid.version, this.type]), this.hash()]);
    };

    BaseKeyPair.prototype.can_sign = function() {
      return this.priv != null;
    };

    BaseKeyPair.prototype.can_decrypt = function() {
      return this.priv != null;
    };

    BaseKeyPair.prototype.fulfills_flags = function(flags) {
      return false;
    };

    BaseKeyPair.prototype.is_toxic = function() {
      return false;
    };

    BaseKeyPair.prototype.eq = function(k2) {
      return (this.type === k2.type) && (bufeq_secure(this.serialize(), k2.serialize()));
    };

    BaseKeyPair.prototype.can_perform = function(ops_mask) {
      if ((ops_mask & konst.ops.sign) && !this.can_sign()) {
        return false;
      } else if ((ops_mask & konst.ops.decrypt) && !this.can_decrypt()) {
        return false;
      } else {
        return true;
      }
    };

    BaseKeyPair.parse = function(klass, pub_raw) {
      var err, key, len, _ref;
      _ref = klass.Pub.alloc(pub_raw), err = _ref[0], key = _ref[1], len = _ref[2];
      if (key != null) {
        key = new klass({
          pub: key
        });
      }
      return [err, key, len];
    };

    BaseKeyPair.prototype.add_priv = function(priv_raw) {
      var err, len, _ref;
      _ref = Priv.alloc(priv_raw), err = _ref[0], this.priv = _ref[1], len = _ref[2];
      return [err, len];
    };

    BaseKeyPair.alloc = function(klass, _arg) {
      var err, priv, pub, _ref, _ref1;
      pub = _arg.pub, priv = _arg.priv;
      _ref = klass.Pub.alloc(pub), err = _ref[0], pub = _ref[1];
      if ((err == null) && (priv != null)) {
        _ref1 = klass.Priv.alloc(priv, pub), err = _ref1[0], priv = _ref1[1];
      }
      if (err != null) {
        return [err, null];
      } else {
        return [
          null, new klass({
            priv: priv,
            pub: pub
          })
        ];
      }
    };

    BaseKeyPair.prototype.read_priv = function(raw_priv) {
      var err, _ref;
      _ref = this.Priv.alloc(raw_priv, this.pub), err = _ref[0], this.priv = _ref[1];
      return err;
    };

    return BaseKeyPair;

  })();

}).call(this);
