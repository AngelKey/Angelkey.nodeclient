// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var C, Decryptor, MDC, MDC_Parser, PKESK, PKESK_Parser, Packet, SEIPD, SEIPD_Parser, SHA1, asymmetric, bufeq_fast, bufeq_secure, encrypt, iced, uint_to_buffer, __iced_k, __iced_k_noop, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  Packet = require('./base').Packet;

  C = require('../../const').openpgp;

  asymmetric = require('../../asymmetric');

  SHA1 = require('../../hash').SHA1;

  _ref = require('../../util'), uint_to_buffer = _ref.uint_to_buffer, bufeq_secure = _ref.bufeq_secure, bufeq_fast = _ref.bufeq_fast;

  _ref1 = require('../ocfb'), encrypt = _ref1.encrypt, Decryptor = _ref1.Decryptor;

  PKESK = (function(_super) {
    __extends(PKESK, _super);

    function PKESK(_arg) {
      this.crypto_type = _arg.crypto_type, this.key_id = _arg.key_id, this.ekey = _arg.ekey;
    }

    PKESK.parse = function(slice) {
      return (new PKESK_Parser(slice)).parse();
    };

    PKESK.prototype.to_esk_packet = function() {
      return this;
    };

    PKESK.prototype.get_key_id = function() {
      return this.key_id;
    };

    PKESK.prototype.write_unframed = function(cb) {
      var bufs, err, ret;
      bufs = [uint_to_buffer(8, C.versions.PKESK), this.key_id, uint_to_buffer(8, this.crypto_type), this.ekey.output()];
      ret = Buffer.concat(bufs);
      err = null;
      return cb(err, ret);
    };

    PKESK.prototype.write = function(cb) {
      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      ret = null;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
            funcname: "PKESK.write"
          });
          _this.write_unframed(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return unframed = arguments[1];
              };
            })(),
            lineno: 34
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            ret = _this.frame_packet(C.packet_tags.PKESK, unframed);
          }
          return cb(err, ret);
        };
      })(this));
    };

    return PKESK;

  })(Packet);

  SEIPD = (function(_super) {
    __extends(SEIPD, _super);

    function SEIPD(_arg) {
      this.ciphertext = _arg.ciphertext;
    }

    SEIPD.parse = function(slice) {
      return (new SEIPD_Parser(slice)).parse();
    };

    SEIPD.prototype.to_enc_data_packet = function() {
      return this;
    };

    SEIPD.prototype.check = function() {};

    SEIPD.prototype.decrypt = function(cipher) {
      var eng, err, mdc, plaintext, prefix, pt, _ref2;
      eng = new Decryptor({
        cipher: cipher,
        ciphertext: this.ciphertext
      });
      err = eng.check();
      if (err != null) {
        throw err;
      }
      pt = eng.dec();
      _ref2 = MDC.parse(pt), mdc = _ref2[0], plaintext = _ref2[1];
      prefix = eng.get_prefix();
      mdc.compute({
        prefix: prefix,
        plaintext: plaintext
      });
      if (!mdc.check()) {
        throw new Error("MDC mismatch");
      }
      return plaintext;
    };

    SEIPD.prototype.encrypt = function(_arg, cb) {
      var cipher, mdc, mdc_buf, plaintext, prefixrandom;
      cipher = _arg.cipher, plaintext = _arg.plaintext, prefixrandom = _arg.prefixrandom;
      mdc = new MDC({});
      mdc_buf = mdc.compute({
        plaintext: plaintext,
        prefix: prefixrandom
      });
      plaintext = Buffer.concat([plaintext, MDC.header, mdc_buf]);
      this.ciphertext = encrypt({
        cipher: cipher,
        plaintext: plaintext,
        prefixrandom: prefixrandom
      });
      return cb(null);
    };

    SEIPD.prototype.write_unframed = function(cb) {
      var err, ret;
      err = ret = null;
      ret = Buffer.concat([uint_to_buffer(8, C.versions.SEIPD), this.ciphertext]);
      return cb(err, ret);
    };

    SEIPD.prototype.write = function(cb) {
      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      ret = err = null;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
            funcname: "SEIPD.write"
          });
          _this.write_unframed(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return unframed = arguments[1];
              };
            })(),
            lineno: 90
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (err == null) {
            ret = _this.frame_packet(C.packet_tags.SEIPD, unframed);
          }
          return cb(err, ret);
        };
      })(this));
    };

    return SEIPD;

  })(Packet);

  MDC = (function(_super) {
    __extends(MDC, _super);

    MDC.header = new Buffer([0xc0 | C.packet_tags.MDC, SHA1.output_length]);

    MDC.prototype.header = MDC.header;

    function MDC(_arg) {
      this.digest = _arg.digest;
    }

    MDC.parse = function(buf) {
      return (new MDC_Parser(buf)).parse();
    };

    MDC.prototype.compute = function(_arg) {
      var plaintext, prefix;
      plaintext = _arg.plaintext, prefix = _arg.prefix;
      this.computed = SHA1(Buffer.concat([prefix, prefix.slice(-2), plaintext, this.header]));
      return this.computed;
    };

    MDC.prototype.check = function() {
      return bufeq_secure(this.digest, this.computed);
    };

    return MDC;

  })(Packet);

  MDC_Parser = (function() {
    function MDC_Parser(buf) {
      this.buf = buf;
    }

    MDC_Parser.prototype.parse = function() {
      var chunk, digest, hl, len, rem;
      hl = MDC.header.length;
      len = SHA1.output_length + hl;
      rem = this.buf.slice(0, -len);
      chunk = this.buf.slice(-len);
      if (!bufeq_fast(chunk.slice(0, hl), MDC.header)) {
        throw new Error('Missing MDC header');
      }
      digest = chunk.slice(hl);
      return [
        new MDC({
          digest: digest
        }), rem
      ];
    };

    return MDC_Parser;

  })();

  SEIPD_Parser = (function() {
    function SEIPD_Parser(slice) {
      this.slice = slice;
    }

    SEIPD_Parser.prototype.payload_split = function(raw) {};

    SEIPD_Parser.prototype.parse = function() {
      var ciphertext, v;
      if ((v = this.slice.read_uint8()) !== C.versions.SEIPD) {
        throw new Error("Unknown SEIPD version " + v);
      }
      ciphertext = this.slice.consume_rest_to_buffer();
      return new SEIPD({
        ciphertext: ciphertext
      });
    };

    return SEIPD_Parser;

  })();

  PKESK_Parser = (function() {
    function PKESK_Parser(slice) {
      this.slice = slice;
    }

    PKESK_Parser.prototype.parse = function() {
      var crypto_type, ekey, key_id, klass, v;
      if ((v = this.slice.read_uint8()) !== C.versions.PKESK) {
        throw new Error("Unknown PKESK version: " + v);
      }
      key_id = this.slice.read_buffer(8);
      crypto_type = this.slice.read_uint8();
      klass = asymmetric.get_class(crypto_type);
      ekey = klass.parse_output(this.slice.consume_rest_to_buffer());
      return new PKESK({
        crypto_type: crypto_type,
        key_id: key_id,
        ekey: ekey
      });
    };

    return PKESK_Parser;

  })();

  exports.SEIPD = SEIPD;

  exports.PKESK = PKESK;

  exports.MDC = MDC;

}).call(this);
