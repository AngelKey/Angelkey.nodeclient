{
  "tests": {
    "test_ralph_sig_chain": {
      "_comment": "Ralph is a test user I created by hand on my local server. I fetched his sigs and keys from the API, and then massaged them into our input format. This test is mainly to make sure that the generated chains we're using in other tests bear some relationship to reality.  - Jack",
      "input": "ralph_chain.json",
      "len": 5,
      "sibkeys": 3,
      "subkeys": 2,
      "eldest": "second_eldest"
    },

    "test_simple_chain": {
      "_comment": "Test a simple chain, just one link.",
      "input": "simple_chain.json",
      "len": 1,
      "sibkeys": 1,
      "subkeys": 0
    },

    "test_error_unknown_key": {
      "_comment": "Check the case where a signing kid is simply missing from the list of available keys (as opposed to invalid for some other reason, like having been revoked).",
      "input": "missing_kid_chain.json",
      "eldest": "e",
      "err_type": "NONEXISTENT_KID"
    },

    "test_error_unknown_reverse_sig_key": {
      "_comment": "As above, but for a reverse sig.",
      "input": "missing_reverse_kid_chain.json",
      "eldest": "e",
      "err_type": "NONEXISTENT_KID"
    },

    "test_error_bad_signature": {
      "_comment": "Change some bytes from the valid signature, and confirm it gets rejected.",
      "input": "bad_signature_chain.json",
      "err_type": "VERIFY_FAILED"
    },

    "test_error_bad_reverse_signature": {
      "_comment": "Change some bytes from the valid reverse signature, and confirm it gets rejected.",
      "input": "bad_reverse_signature_chain.json",
      "err_type": "REVERSE_SIG_VERIFY_FAILED"
    },

    "test_error_mismatched_kid": {
      "_comment": "We need to use the server-provided KID to unbox a signature. We always need to check back after unboxing to make sure the internal KID matches the one we actually used. This test exercises that check. NOTE: I generated this chain by hacking some code into kbpgp to modify the payload right before it was signed.",
      "input": "mismatched_kid_chain.json",
      "err_type": "KID_MISMATCH"
    },

    "test_error_mismatched_fingerprint": {
      "_comment": "We don't use fingerprints in unboxing, but nonetheless we want to make sure that if a chain link claims to have been signed by a given fingerprint, that does in fact correspond to the KID of the PGP key that signed it. NOTE: I generated this chain by hacking some code into kbpgp to modify the payload right before it was signed.",
      "input": "mismatched_fingerprint_chain.json",
      "err_type": "FINGERPRINT_MISMATCH"
    },

    "test_revokes": {
      "_comment": "The chain is length 10, but after 2 sig revokes it should be length 8. Likewise, 6 keys are delegated, but after 2 sig revokes and 2 key revokes it should be down to 2 keys.",
      "input": "example_revokes_chain.json",
      "len": 13,
      "sibkeys": 2,
      "subkeys": 1
    },

    "test_error_revoked_key": {
      "_comment": "Try signing a link with a key that was previously revoked.",
      "input": "signed_with_revoked_key_chain.json",
      "err_type": "INVALID_SIBKEY"
    },

    "test_error_expired_key": {
      "_comment": "Try signing a link with a key that has expired.",
      "input": "expired_key_chain.json",
      "err_type": "EXPIRED_SIBKEY"
    },

    "test_error_bad_uid": {
      "input": "bad_uid_chain.json",
      "err_type": "WRONG_UID"
    },

    "test_error_bad_username": {
      "input": "bad_username_chain.json",
      "err_type": "WRONG_USERNAME"
    },

    "test_error_bad_prev": {
      "input": "bad_prev_chain.json",
      "err_type": "WRONG_PREV"
    },

    "test_error_bad_seqno": {
      "input": "bad_seqno_chain.json",
      "err_type": "WRONG_SEQNO"
    },

    "test_empty_sigchain": {
      "input": "empty_chain.json",
      "len": 0,
      "sibkeys": 1,
      "subkeys": 0,
      "eldest": "ralph"
    },

    "test_error_empty_sigchain_bad_key_userid": {
      "input": "empty_chain.json",
      "eldest": "steve",
      "err_type": "KEY_OWNERSHIP"
    },

    "test_error_empty_sigchain_nonexistent_pgp": {
      "input": "empty_chain.json",
      "eldest": "nonexistent",
      "err_type": "NONEXISTENT_KID"
    },

    "test_error_empty_sigchain_eldest_key_is_nacl": {
      "_comment": "NaCl keys don't have any internal userid info, so they can't stand alone as an eldest key without having signed some links.",
      "input": "empty_chain.json",
      "eldest": "naclkey",
      "err_type": "KEY_OWNERSHIP"
    },

    "test_jack_chain": {
      "_comment": "Just a sanity check with my own sigchain",
      "input": "jack_chain.json",
      "len": 29,
      "sibkeys": 1,
      "subkeys": 0
    },

    "test_error_missing_first_link": {
      "_comment": "We need to make sure the server can't drop links off the front. This would be a risk if we assumed that, for example, they belonged to a previous eldest key.",
      "input": "jack_chain_missing_first_link.json",
      "err_type": "WRONG_SEQNO"
    },

    "test_error_substitute_first_link": {
      "_comment": "Here the first link has been substituted for one signed by a different eldest key. We should notice the payload hash mismatch.",
      "input": "jack_chain_substitute_first_link.json",
      "eldest": "real_eldest",
      "err_type": "WRONG_PREV"
    },

    "test_error_later_subchain": {
      "_comment": "The current eldest key should always correspond to the latest subchain.",
      "input": "ralph_chain.json",
      "eldest": "first_eldest",
      "err_type": "NOT_LATEST_SUBCHAIN"
    },

    "test_ralph_with_new_eldest_key": {
      "input": "ralph_chain.json",
      "eldest": "new_eldest",
      "len": 0,
      "sibkeys": 1,
      "subkeys": 0
    },

    "test_melvin_with_expiring_pgp_key": {
      "_comment": "Right now this just exercises some of the code that recognizes the expiration time. Eventually we should add tests that make sure the etime is really enforced.",
      "input": "melvin_chain.json",
      "len": 1,
      "sibkeys": 1,
      "subkeys": 0
    },

    "test_error_ralph_with_missing_subkey": {
      "input": "nonexistent_subkey_chain.json",
      "err_type": "NONEXISTENT_KID"
    }
  }
}
