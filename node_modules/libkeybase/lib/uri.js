// Generated by IcedCoffeeScript 1.7.1-f
(function() {
  "#\n#  Key-identier URIs, like:\n#\n#    kbk://max@/aabbccee20/iphone+2\n#    kbk://max@keybase.io/aabbccee20/iphone+2   [equivalent to the above]\n#    kbk://max;fingerprint=8EFBE2E4DD56B35273634E8F6052B2AD31A6631C@/aabbccee20/iphone+3 [pinning a key]\n#\n#  We're going off of URI-scheme as in this page:\n#     - official: http://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml\n#     - conventional: http://en.wikipedia.org/wiki/URI_scheme\n#\n#  Within those schemes, that for SSH looks sort of like the above:\n#     - https://tools.ietf.org/html/draft-ietf-secsh-scp-sftp-ssh-uri-04\n#\n#  In the above examples, 'aabbccee20' is an App ID.\n#";
  var URI;

  exports.URI = URI = (function() {
    function URI(_arg) {
      this.username = _arg.username, this.fingerprint = _arg.fingerprint, this.app_id = _arg.app_id, this.device_id = _arg.device_id, this.host = _arg.host, this.port = _arg.port;
    }

    URI.prototype.format = function(_arg) {
      var app_id, authority, full, host, parts;
      full = _arg.full;
      parts = ["kbk:/"];
      if (!this.username) {
        throw new Error("need username");
      }
      authority = this.username;
      if (this.fingerprint != null) {
        authority += ";fingerprint=" + this.fingerprint;
      }
      authority += "@";
      host = this.host || (full ? "keybase.io" : null);
      if (host != null) {
        authority += "" + host;
      }
      if ((this.port != null) && this.port !== 443) {
        authority += ":" + this.port;
      }
      parts.push(authority);
      app_id = this.app_id || 0;
      parts.push(app_id);
      if (this.device_id) {
        parts.push(this.device_id);
      }
      return parts.join("/").toLowerCase();
    };

    URI.parse = function(s) {
      var authority, hier, host, k, obj, parts, port, ui, userinfo, username, v, _i, _len, _ref, _ref1;
      obj = {};
      parts = s.split('/');
      if (parts.length < 3 || parts[0] !== 'kbk:' || parts[1].length !== 0) {
        throw new Error("" + s + ": can't parse keybase URI that doesn't start with kbk://");
      }
      authority = parts[2].split("@");
      if (authority.length !== 2) {
        throw new Error("" + s + ": 'authority' section must be username@[host]");
      }
      userinfo = authority[0].split(";");
      username = userinfo[0];
      if (!((username != null) && username.length)) {
        throw new Error("" + s + ": 'username' section is required");
      }
      obj.username = username;
      _ref = userinfo.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ui = _ref[_i];
        _ref1 = ui.split("="), k = _ref1[0], v = _ref1[1];
        if (k === "fingerprint") {
          obj.fingerprint = v;
        } else {
          throw new Error("" + s + ": 'fingerprint=' is the only userinfo now allowed");
        }
      }
      if (authority[1].length > 0) {
        host = authority[1].split(':');
        if (host.length > 2) {
          throw new Error("" + s + ": [hostname[:port]] did not parse");
        } else {
          obj.host = host[0];
          if (host.length === 2) {
            port = parseInt(host[1], 10);
            if (isNaN(port)) {
              throw new Error("" + s + ": bad port given");
            }
            obj.port = port;
          }
        }
      }
      if (parts.length > 3) {
        hier = parts.slice(3);
        obj.app_id = hier[0];
        obj.device_id = hier.slice(1).join('/');
      }
      obj.app_id || (obj.app_id = 0);
      return new URI(obj);
    };

    URI.prototype.eq = function(uri2) {
      return (this.format({
        full: true
      })) === (uri2.format({
        full: true
      }));
    };

    return URI;

  })();

}).call(this);
