// Generated by IcedCoffeeScript 1.7.1-g
(function() {
  var ChainLink, E, ParsedKeys, SIG_ID_SUFFIX, SigChain, UID_LEN, a_json_parse, athrow, bufeq_secure, check_buffers_equal, check_link_payload_format, current_time_seconds, error_names, errors_map, iced, ie, kbpgp, make_esc, name, proofs, __iced_k, __iced_k_noop, _i, _len, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  _ref = require('iced-utils').util, bufeq_secure = _ref.bufeq_secure, athrow = _ref.athrow, a_json_parse = _ref.a_json_parse;

  make_esc = require('iced-error').make_esc;

  kbpgp = require('kbpgp');

  proofs = require('keybase-proofs');

  ie = require('iced-error');

  UID_LEN = 32;

  exports.SIG_ID_SUFFIX = SIG_ID_SUFFIX = "0f";

  exports.debug = {
    unbox_count: 0
  };

  exports.ParsedKeys = ParsedKeys = ParsedKeys = (function() {
    ParsedKeys.parse = function(_arg, cb) {
      var bundle, default_eldest_kid_for_testing, esc, existing, key_bundles, key_manager, kid, kid_str, kids_to_key_managers, opts, parsed_keys, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key_bundles = _arg.key_bundles;
      esc = make_esc(cb, "ParsedKeys.parse");
      kids_to_key_managers = {};
      default_eldest_kid_for_testing = null;
      opts = {
        time_travel: true
      };
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref1, _results, _while;
          _ref1 = key_bundles;
          _len = _ref1.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              bundle = _ref1[_i];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ParsedKeys.parse"
                });
                kbpgp.ukm.import_armored_public({
                  armored: bundle,
                  opts: opts
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key_manager = arguments[0];
                    };
                  })(),
                  lineno: 25
                })));
                __iced_deferrals._fulfill();
              })(function() {
                kid = key_manager.get_ekid();
                kid_str = kid.toString("hex");
                if ((existing = kids_to_key_managers[kid_str]) != null) {
                  existing.merge_subkeys(key_manager);
                } else {
                  kids_to_key_managers[kid_str] = key_manager;
                }
                return _next(default_eldest_kid_for_testing || (default_eldest_kid_for_testing = kid_str));
              });
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          parsed_keys = new ParsedKeys({
            kids_to_key_managers: kids_to_key_managers
          });
          return cb(null, parsed_keys, default_eldest_kid_for_testing);
        };
      })(this));
    };

    function ParsedKeys(_arg) {
      var kids_to_key_managers;
      kids_to_key_managers = _arg.kids_to_key_managers;
      this._kids_to_key_managers = kids_to_key_managers;
    }

    ParsedKeys.prototype.get_key_manager = function(kid) {
      return this._kids_to_key_managers[kid];
    };

    return ParsedKeys;

  })();

  ChainLink = (function() {
    ChainLink.parse = function(_arg, cb) {
      var esc, parsed_keys, payload, payload_hash, sig_blob, sig_cache, sig_id, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, parsed_keys = _arg.parsed_keys, sig_cache = _arg.sig_cache;
      esc = make_esc(cb, "ChainLink.parse");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
            funcname: "ChainLink.parse"
          });
          _this._unbox_payload({
            sig_blob: sig_blob,
            parsed_keys: parsed_keys,
            sig_cache: sig_cache
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                payload = arguments[0];
                sig_id = arguments[1];
                return payload_hash = arguments[2];
              };
            })(),
            lineno: 59
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "ChainLink.parse"
            });
            check_link_payload_format({
              payload: payload
            }, esc(__iced_deferrals.defer({
              lineno: 61
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink.parse"
              });
              _this._check_payload_against_server_kid({
                sig_blob: sig_blob,
                payload: payload,
                parsed_keys: parsed_keys
              }, esc(__iced_deferrals.defer({
                lineno: 64
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ChainLink.parse"
                });
                _this._check_reverse_signatures({
                  payload: payload,
                  parsed_keys: parsed_keys
                }, esc(__iced_deferrals.defer({
                  lineno: 66
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return cb(null, new ChainLink({
                  kid: sig_blob.kid,
                  sig_id: sig_id,
                  payload: payload,
                  payload_hash: payload_hash
                }));
              });
            });
          });
        };
      })(this));
    };

    ChainLink._unbox_payload = function(_arg, cb) {
      var ctime_seconds, err, esc, key_manager, kid, parsed_keys, payload, payload_hash, payload_json, sig_blob, sig_body, sig_cache, sig_eng, sig_id, unverified_buffer, verified_buffer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, parsed_keys = _arg.parsed_keys, sig_cache = _arg.sig_cache;
      esc = make_esc(cb, "ChainLink._unbox_payload");
      kid = sig_blob.kid;
      key_manager = parsed_keys.get_key_manager(kid);
      (function(_this) {
        return (function(__iced_k) {
          if (key_manager == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink._unbox_payload"
              });
              athrow(new E.NonexistentKidError("link signed by nonexistent kid " + kid), esc(__iced_deferrals.defer({
                lineno: 78
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          sig_eng = key_manager.make_sig_eng();
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "ChainLink._unbox_payload"
            });
            sig_eng.get_body_and_unverified_payload({
              armored: sig_blob.sig
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  sig_body = arguments[0];
                  return unverified_buffer = arguments[1];
                };
              })(),
              lineno: 84
            })));
            __iced_deferrals._fulfill();
          })(function() {
            sig_id = kbpgp.hash.SHA256(sig_body).toString("hex") + SIG_ID_SUFFIX;
            payload_hash = kbpgp.hash.SHA256(unverified_buffer).toString("hex");
            payload_json = unverified_buffer.toString('utf8');
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink._unbox_payload"
              });
              a_json_parse(payload_json, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return payload = arguments[0];
                  };
                })(),
                lineno: 88
              })));
              __iced_deferrals._fulfill();
            })(function() {
              ctime_seconds = payload.ctime;
              (function(__iced_k) {
                if (sig_cache != null) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "ChainLink._unbox_payload"
                    });
                    sig_cache.get({
                      sig_id: sig_id
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return verified_buffer = arguments[0];
                        };
                      })(),
                      lineno: 92
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(function() {
                (function(__iced_k) {
                  if (typeof verified_buffer === "undefined" || verified_buffer === null) {
                    exports.debug.unbox_count++;
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                        funcname: "ChainLink._unbox_payload"
                      });
                      key_manager.make_sig_eng().unbox(sig_blob.sig, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            err = arguments[0];
                            return verified_buffer = arguments[1];
                          };
                        })(),
                        lineno: 97
                      }), {
                        now: ctime_seconds
                      });
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        if (typeof err !== "undefined" && err !== null) {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                              funcname: "ChainLink._unbox_payload"
                            });
                            athrow(new E.VerifyFailedError(err.message), esc(__iced_deferrals.defer({
                              lineno: 100
                            })));
                            __iced_deferrals._fulfill();
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(function() {
                        (function(__iced_k) {
                          if (sig_cache != null) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                                funcname: "ChainLink._unbox_payload"
                              });
                              sig_cache.put({
                                sig_id: sig_id,
                                payload_buffer: verified_buffer
                              }, esc(__iced_deferrals.defer({
                                lineno: 102
                              })));
                              __iced_deferrals._fulfill();
                            })(__iced_k);
                          } else {
                            return __iced_k();
                          }
                        })(__iced_k);
                      });
                    });
                  } else {
                    return __iced_k();
                  }
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "ChainLink._unbox_payload"
                    });
                    check_buffers_equal(verified_buffer, unverified_buffer, esc(__iced_deferrals.defer({
                      lineno: 107
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return cb(null, payload, sig_id, payload_hash);
                  });
                });
              });
            });
          });
        };
      })(this));
    };

    ChainLink._check_payload_against_server_kid = function(_arg, cb) {
      var err, parsed_keys, payload, payload_fingerprint, payload_kid, sig_blob, signing_fingerprint, signing_kid, _ref1;
      sig_blob = _arg.sig_blob, payload = _arg.payload, parsed_keys = _arg.parsed_keys;
      signing_kid = sig_blob.kid;
      signing_fingerprint = (_ref1 = parsed_keys.get_key_manager(signing_kid).get_pgp_fingerprint()) != null ? _ref1.toString('hex') : void 0;
      payload_kid = payload.body.key.kid;
      payload_fingerprint = payload.body.key.fingerprint;
      err = null;
      if ((payload_kid != null) && payload_kid !== signing_kid) {
        err = new E.KidMismatchError("signing kid (" + signing_kid + ") and payload kid (" + payload_kid + ") mismatch");
      } else if ((payload_fingerprint != null) && payload_fingerprint !== signing_fingerprint) {
        err = new E.FingerprintMismatchError("signing fingerprint (" + signing_fingerprint + ") and payload fingerprint (" + payload_fingerprint + ") mismatch");
      }
      return cb(err);
    };

    ChainLink._check_reverse_signatures = function(_arg, cb) {
      var err, esc, key_manager, kid, parsed_keys, payload, sibkey_proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      payload = _arg.payload, parsed_keys = _arg.parsed_keys;
      esc = make_esc(cb, "ChainLink._check_reverse_signatures");
      (function(_this) {
        return (function(__iced_k) {
          if (payload.body.sibkey != null) {
            kid = payload.body.sibkey.kid;
            key_manager = parsed_keys.get_key_manager(kid);
            (function(__iced_k) {
              if (key_manager == null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "ChainLink._check_reverse_signatures"
                  });
                  athrow(new E.NonexistentKidError("link reverse-signed by nonexistent kid " + kid), esc(__iced_deferrals.defer({
                    lineno: 130
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              sibkey_proof = new proofs.Sibkey({});
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ChainLink._check_reverse_signatures"
                });
                sibkey_proof.reverse_sig_check({
                  json: payload,
                  subkm: key_manager
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 132
                }));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  if (typeof err !== "undefined" && err !== null) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                        funcname: "ChainLink._check_reverse_signatures"
                      });
                      athrow(new E.ReverseSigVerifyFailedError(err.message), esc(__iced_deferrals.defer({
                        lineno: 134
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  } else {
                    return __iced_k();
                  }
                })(__iced_k);
              });
            });
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (payload.body.subkey != null) {
              kid = payload.body.subkey.kid;
              key_manager = parsed_keys.get_key_manager(kid);
              (function(__iced_k) {
                if (key_manager == null) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "ChainLink._check_reverse_signatures"
                    });
                    athrow(new E.NonexistentKidError("link delegates nonexistent subkey " + kid), esc(__iced_deferrals.defer({
                      lineno: 139
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    function ChainLink(_arg) {
      var _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      this.kid = _arg.kid, this.sig_id = _arg.sig_id, this.payload = _arg.payload, this.payload_hash = _arg.payload_hash;
      this.uid = this.payload.body.key.uid;
      this.username = this.payload.body.key.username;
      this.seqno = this.payload.seqno;
      this.prev = this.payload.prev;
      this.fingerprint = this.payload.body.key.fingerprint;
      this.eldest_kid = this.payload.body.key.eldest_kid || this.kid;
      this.ctime_seconds = this.payload.ctime;
      this.etime_seconds = this.ctime_seconds + this.payload.expire_in;
      this.sibkey_delegation = (_ref1 = this.payload.body.sibkey) != null ? _ref1.kid : void 0;
      this.subkey_delegation = (_ref2 = this.payload.body.subkey) != null ? _ref2.kid : void 0;
      this.key_revocations = [];
      if (((_ref3 = this.payload.body.revoke) != null ? _ref3.kids : void 0) != null) {
        this.key_revocations = this.payload.body.revoke.kids;
      }
      if (((_ref4 = this.payload.body.revoke) != null ? _ref4.kid : void 0) != null) {
        this.key_revocations.push(this.payload.body.revoke.kid);
      }
      this.sig_revocations = [];
      if (((_ref5 = this.payload.body.revoke) != null ? _ref5.sig_ids : void 0) != null) {
        this.sig_revocations = this.payload.body.revoke.sig_ids;
      }
      if (((_ref6 = this.payload.body.revoke) != null ? _ref6.sig_id : void 0) != null) {
        this.sig_revocations.push(this.payload.body.revoke.sig_id);
      }
    }

    return ChainLink;

  })();

  exports.check_link_payload_format = check_link_payload_format = function(_arg, cb) {
    var esc, payload, uid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    payload = _arg.payload;
    esc = make_esc(cb, "check_link_payload_format");
    uid = payload.body.key.uid;
    (function(_this) {
      return (function(__iced_k) {
        if (uid.length !== UID_LEN) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced"
            });
            athrow(new E.BadLinkFormatError("UID wrong length: " + uid.length), esc(__iced_deferrals.defer({
              lineno: 176
            })));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      });
    })(this)((function(_this) {
      return function() {
        return cb();
      };
    })(this));
  };

  exports.check_buffers_equal = check_buffers_equal = function(verified_buffer, unverified_buffer, cb) {
    var err, msg;
    err = null;
    if (!bufeq_secure(verified_buffer, unverified_buffer)) {
      msg = "Payload mismatch!\nVerified:\n" + (verified_buffer.toString('hex')) + "\nUnverified:\n" + (unverified_buffer.toString('hex'));
      err = new E.VerifyFailedError(msg);
    }
    return cb(err);
  };

  exports.SigChain = SigChain = (function() {
    SigChain.replay = function(_arg, cb) {
      var eldest_kid, esc, log, parsed_keys, sig_blob, sig_blobs, sig_cache, sigchain, uid, username, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blobs = _arg.sig_blobs, parsed_keys = _arg.parsed_keys, sig_cache = _arg.sig_cache, uid = _arg.uid, username = _arg.username, eldest_kid = _arg.eldest_kid, log = _arg.log;
      log = log || (function() {});
      log("+ libkeybase: replay(username: " + username + ", uid: " + uid + ", eldest: " + eldest_kid + ")");
      esc = make_esc(cb, "SigChain.replay");
      (function(_this) {
        return (function(__iced_k) {
          if (eldest_kid == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain.replay"
              });
              athrow(new Error("eldest_kid parameter is required"), esc(__iced_deferrals.defer({
                lineno: 225
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          sigchain = new SigChain({
            uid: uid,
            username: username,
            eldest_kid: eldest_kid,
            parsed_keys: parsed_keys
          });
          (function(__iced_k) {
            var _i, _len, _ref1, _results, _while;
            _ref1 = sig_blobs;
            _len = _ref1.length;
            _i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++_i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(_i < _len)) {
                return _break();
              } else {
                sig_blob = _ref1[_i];
                log("| libkeybase: replaying signature " + sig_blob.seqno + ": " + sig_blob.sig_id);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain.replay"
                  });
                  sigchain._add_new_link({
                    sig_blob: sig_blob,
                    sig_cache: sig_cache,
                    log: log
                  }, esc(__iced_deferrals.defer({
                    lineno: 231
                  })));
                  __iced_deferrals._fulfill();
                })(_next);
              }
            };
            _while(__iced_k);
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain.replay"
              });
              sigchain._enforce_eldest_key_ownership({}, esc(__iced_deferrals.defer({
                lineno: 234
              })));
              __iced_deferrals._fulfill();
            })(function() {
              log("- libkeybase: replay finished");
              return cb(null, sigchain);
            });
          });
        };
      })(this));
    };

    function SigChain(_arg) {
      var eldest_kid, parsed_keys, uid, username;
      uid = _arg.uid, username = _arg.username, eldest_kid = _arg.eldest_kid, parsed_keys = _arg.parsed_keys;
      this._uid = uid;
      this._username = username;
      this._eldest_kid = eldest_kid;
      this._parsed_keys = parsed_keys;
      this._links = [];
      this._next_seqno = 1;
      this._next_payload_hash = null;
      this._unrevoked_links = {};
      this._valid_sibkeys = {};
      this._sibkey_order = [eldest_kid];
      this._valid_sibkeys[eldest_kid] = true;
      this._valid_subkeys = {};
      this._subkey_order = [];
      this._eldest_key_delegated = false;
      this._eldest_key_verified = false;
      this._kid_to_etime_seconds = {};
      this._update_kid_pgp_etime({
        kid: eldest_kid
      });
    }

    SigChain.prototype.get_links = function() {
      var link;
      return (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this._links;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          link = _ref1[_i];
          if (link.sig_id in this._unrevoked_links) {
            _results.push(link);
          }
        }
        return _results;
      }).call(this);
    };

    SigChain.prototype.get_sibkeys = function(_arg) {
      var etime, expired, kid, now, ret, _i, _len, _ref1;
      now = _arg.now;
      now = now || current_time_seconds();
      ret = [];
      _ref1 = this._sibkey_order;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        kid = _ref1[_i];
        etime = this._kid_to_etime_seconds[kid];
        expired = (etime != null) && now > etime;
        if (this._valid_sibkeys[kid] && !expired) {
          ret.push(this._parsed_keys.get_key_manager(kid));
        }
      }
      return ret;
    };

    SigChain.prototype.get_subkeys = function(_arg) {
      var etime, expired, kid, now, ret, _i, _len, _ref1;
      now = _arg.now;
      now = now || current_time_seconds();
      ret = [];
      _ref1 = this._subkey_order;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        kid = _ref1[_i];
        etime = this._kid_to_etime_seconds[kid];
        expired = (etime != null) && now > etime;
        if (this._valid_subkeys[kid] && !expired) {
          ret.push(this._parsed_keys.get_key_manager(kid));
        }
      }
      return ret;
    };

    SigChain.prototype._add_new_link = function(_arg, cb) {
      var esc, link, log, sig_blob, sig_cache, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, sig_cache = _arg.sig_cache, log = _arg.log;
      esc = make_esc(cb, "SigChain._add_new_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
            funcname: "SigChain._add_new_link"
          });
          ChainLink.parse({
            sig_blob: sig_blob,
            parsed_keys: _this._parsed_keys,
            sig_cache: sig_cache
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return link = arguments[0];
              };
            })(),
            lineno: 292
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          log("| libkeybase: chain link parsed, type '" + link.payload.body.type + "'");
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "SigChain._add_new_link"
            });
            _this._check_link_belongs_here({
              link: link
            }, esc(__iced_deferrals.defer({
              lineno: 297
            })));
            __iced_deferrals._fulfill();
          })(function() {
            if (link.eldest_kid !== _this._eldest_kid) {
              if (_this._links.length === 0) {
                log("| libkeybase: link not in the current subchain -- skipping ahead");
                cb(null);
                return;
              } else {
                cb(new E.NotLatestSubchainError("Found a later subchain with eldest kid " + link.eldest_kid));
                return;
              }
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain._add_new_link"
              });
              _this._check_key_is_valid({
                link: link
              }, esc(__iced_deferrals.defer({
                lineno: 316
              })));
              __iced_deferrals._fulfill();
            })(function() {
              log("| libkeybase: signing key is valid (" + link.kid + ")");
              _this._links.push(link);
              _this._unrevoked_links[link.sig_id] = link;
              if (link.kid === _this._eldest_kid) {
                _this._eldest_key_verified = true;
              }
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "SigChain._add_new_link"
                });
                _this._delegate_keys({
                  link: link,
                  log: log
                }, esc(__iced_deferrals.defer({
                  lineno: 325
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain._add_new_link"
                  });
                  _this._revoke_keys_and_sigs({
                    link: link,
                    log: log
                  }, esc(__iced_deferrals.defer({
                    lineno: 326
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  return cb(null);
                });
              });
            });
          });
        };
      })(this));
    };

    SigChain.prototype._check_link_belongs_here = function(_arg, cb) {
      var err, link;
      link = _arg.link;
      err = null;
      if (link.uid !== this._uid) {
        err = new E.WrongUidError("Link doesn't refer to the right uid, expected: " + link.uid + " got: " + this._uid);
      } else if (link.username.toLowerCase() !== this._username.toLowerCase()) {
        err = new E.WrongUsernameError("Link doesn't refer to the right username, expected: " + link.username + " got: " + this._username);
      } else if (link.seqno !== this._next_seqno) {
        err = new E.WrongSeqnoError("Link sequence number is wrong, expected: " + this._next_seqno + " got: " + link.seqno);
      } else if ((this._next_payload_hash != null) && link.prev !== this._next_payload_hash) {
        err = new E.WrongPrevError("Previous payload hash doesn't match, expected: " + this._next_payload_hash + " got: " + link.prev);
      }
      this._next_seqno++;
      this._next_payload_hash = link.payload_hash;
      return cb(err);
    };

    SigChain.prototype._check_key_is_valid = function(_arg, cb) {
      var err, kid, link;
      link = _arg.link;
      err = null;
      if (!(link.kid in this._valid_sibkeys)) {
        err = new E.InvalidSibkeyError("not a valid sibkey: " + link.kid + ", valid sibkeys: " + (JSON.stringify((function() {
          var _results;
          _results = [];
          for (kid in this._valid_sibkeys) {
            _results.push(kid);
          }
          return _results;
        }).call(this))));
      } else if (link.ctime_seconds > this._kid_to_etime_seconds[link.kid]) {
        err = new E.ExpiredSibkeyError("expired sibkey: " + link.kid);
      }
      return cb(err);
    };

    SigChain.prototype._delegate_keys = function(_arg, cb) {
      var link, log;
      link = _arg.link, log = _arg.log;
      if (link.kid === this._eldest_kid && !this._eldest_key_delegated) {
        this._update_kid_etime({
          kid: this._eldest_kid,
          etime_seconds: link.etime_seconds
        });
        this._eldest_key_delegated = true;
      }
      if (link.sibkey_delegation != null) {
        this._valid_sibkeys[link.sibkey_delegation] = true;
        this._sibkey_order.push(link.sibkey_delegation);
        this._update_kid_etime({
          kid: link.sibkey_delegation,
          etime_seconds: link.etime_seconds
        });
        this._update_kid_pgp_etime({
          kid: link.sibkey_delegation
        });
        log("| libkeybase: delegating sibkey " + link.sibkey_delegation);
      }
      if (link.subkey_delegation != null) {
        this._valid_subkeys[link.subkey_delegation] = true;
        this._subkey_order.push(link.subkey_delegation);
        this._update_kid_etime({
          kid: link.subkey_delegation,
          etime_seconds: link.etime_seconds
        });
      }
      return cb();
    };

    SigChain.prototype._update_kid_pgp_etime = function(_arg) {
      var etime_seconds, key_manager, kid, lifespan, _ref1;
      kid = _arg.kid;
      key_manager = this._parsed_keys.get_key_manager(kid);
      lifespan = key_manager != null ? (_ref1 = key_manager.primary) != null ? _ref1.lifespan : void 0 : void 0;
      if ((lifespan != null ? lifespan.expire_in : void 0) != null) {
        etime_seconds = lifespan.generated + lifespan.expire_in;
        return this._update_kid_etime({
          kid: kid,
          etime_seconds: etime_seconds
        });
      }
    };

    SigChain.prototype._update_kid_etime = function(_arg) {
      var etime_seconds, kid;
      kid = _arg.kid, etime_seconds = _arg.etime_seconds;
      if (this._kid_to_etime_seconds[kid] == null) {
        return this._kid_to_etime_seconds[kid] = etime_seconds;
      } else {
        return this._kid_to_etime_seconds[kid] = Math.min(etime_seconds, this._kid_to_etime_seconds[kid]);
      }
    };

    SigChain.prototype._revoke_keys_and_sigs = function(_arg, cb) {
      var kid, link, log, revoked_link, revoked_sibkey, revoked_subkey, sig_id, _i, _j, _len, _len1, _ref1, _ref2;
      link = _arg.link, log = _arg.log;
      _ref1 = link.key_revocations;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        kid = _ref1[_i];
        if (kid in this._valid_sibkeys) {
          log("| libkeybase: revoking sibkey " + kid);
          delete this._valid_sibkeys[kid];
        }
        if (kid in this._valid_subkeys) {
          delete this._valid_subkeys[kid];
        }
      }
      _ref2 = link.sig_revocations;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        sig_id = _ref2[_j];
        if (sig_id in this._unrevoked_links) {
          revoked_link = this._unrevoked_links[sig_id];
          delete this._unrevoked_links[sig_id];
          revoked_sibkey = revoked_link.sibkey_delegation;
          if ((revoked_sibkey != null) && revoked_sibkey in this._valid_sibkeys) {
            log("| libkeybase: revoking sibkey " + revoked_sibkey + " from sig " + sig_id);
            delete this._valid_sibkeys[revoked_sibkey];
          }
          revoked_subkey = revoked_link.subkey_delegation;
          if ((revoked_subkey != null) && revoked_subkey in this._valid_subkeys) {
            delete this._valid_subkeys[revoked_subkey];
          }
        }
      }
      return cb();
    };

    SigChain.prototype._enforce_eldest_key_ownership = function(_arg, cb) {
      var eldest_km, esc, expected_email, identity, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      _arg;
      esc = make_esc(cb, "SigChain._enforce_eldest_key_ownership");
      if (this._eldest_key_verified) {
        cb(null);
        return;
      }
      eldest_km = this._parsed_keys.get_key_manager(this._eldest_kid);
      (function(_this) {
        return (function(__iced_k) {
          if (eldest_km == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain._enforce_eldest_key_ownership"
              });
              athrow(new E.NonexistentKidError("no key for eldest kid " + _this._eldest_kid), esc(__iced_deferrals.defer({
                lineno: 438
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (eldest_km.userids == null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "SigChain._enforce_eldest_key_ownership"
                });
                athrow(new E.KeyOwnershipError("key " + _this._eldest_kid + " is not self-signing"), esc(__iced_deferrals.defer({
                  lineno: 442
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            var _i, _len, _ref1;
            expected_email = _this._username + "@keybase.io";
            _ref1 = eldest_km.userids;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              identity = _ref1[_i];
              if (identity.get_email() === expected_email) {
                cb(null);
                return;
              }
            }
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "SigChain._enforce_eldest_key_ownership"
            });
            athrow(new E.KeyOwnershipError("key " + _this._eldest_kid + " is not owned by " + expected_email), esc(__iced_deferrals.defer({
              lineno: 450
            })));
            __iced_deferrals._fulfill();
          });
        };
      })(this));
    };

    return SigChain;

  })();

  error_names = ["BAD_LINK_FORMAT", "EXPIRED_SIBKEY", "FINGERPRINT_MISMATCH", "INVALID_SIBKEY", "KEY_OWNERSHIP", "KID_MISMATCH", "NONEXISTENT_KID", "NOT_LATEST_SUBCHAIN", "REVERSE_SIG_VERIFY_FAILED", "VERIFY_FAILED", "WRONG_UID", "WRONG_USERNAME", "WRONG_SEQNO", "WRONG_PREV"];

  errors_map = {};

  for (_i = 0, _len = error_names.length; _i < _len; _i++) {
    name = error_names[_i];
    errors_map[name] = "";
  }

  exports.E = E = ie.make_errors(errors_map);

  current_time_seconds = function() {
    return Math.floor(new Date().getTime() / 1000);
  };

  __iced_k_noop();

}).call(this);
