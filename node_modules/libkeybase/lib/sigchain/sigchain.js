// Generated by IcedCoffeeScript 1.7.1-g
(function() {
  var ChainLink, E, KeyState, ParsedKeys, SIG_ID_SUFFIX, SigChain, UID_LEN, a_json_parse, athrow, bufeq_secure, check_buffers_equal, check_link_payload_format, current_time_seconds, error_names, errors_map, iced, ie, kbpgp, make_esc, name, proofs, __iced_k, __iced_k_noop, _i, _len, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  _ref = require('iced-utils').util, bufeq_secure = _ref.bufeq_secure, athrow = _ref.athrow, a_json_parse = _ref.a_json_parse;

  make_esc = require('iced-error').make_esc;

  kbpgp = require('kbpgp');

  proofs = require('keybase-proofs');

  ie = require('iced-error');

  UID_LEN = 32;

  exports.SIG_ID_SUFFIX = SIG_ID_SUFFIX = "0f";

  exports.debug = {
    unbox_count: 0
  };

  exports.ParsedKeys = ParsedKeys = ParsedKeys = (function() {
    ParsedKeys.parse = function(_arg, cb) {
      var bundle, default_eldest_kid_for_testing, esc, key_bundles, key_manager, opts, parsed_keys, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key_bundles = _arg.key_bundles;
      esc = make_esc(cb, "ParsedKeys.parse");
      default_eldest_kid_for_testing = null;
      opts = {
        time_travel: true
      };
      parsed_keys = new ParsedKeys;
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref1, _results, _while;
          _ref1 = key_bundles;
          _len = _ref1.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              bundle = _ref1[_i];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ParsedKeys.parse"
                });
                kbpgp.ukm.import_armored_public({
                  armored: bundle,
                  opts: opts
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key_manager = arguments[0];
                    };
                  })(),
                  lineno: 25
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "ParsedKeys.parse"
                  });
                  parsed_keys._add_key({
                    key_manager: key_manager
                  }, esc(__iced_deferrals.defer({
                    lineno: 26
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  return _next(default_eldest_kid_for_testing || (default_eldest_kid_for_testing = key_manager.get_ekid().toString("hex")));
                });
              });
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(null, parsed_keys, default_eldest_kid_for_testing);
        };
      })(this));
    };

    function ParsedKeys() {
      this._kids_to_merged_pgp_key_managers = {};
      this._kids_to_pgp_key_managers_by_hash = {};
      this._kids_to_nacl_keys = {};
    }

    ParsedKeys.prototype._add_key = function(_arg, cb) {
      var esc, existing, hash, key_manager, kid, kid_str, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key_manager = _arg.key_manager;
      esc = make_esc("ParsedKeys._add_key");
      kid = key_manager.get_ekid();
      kid_str = kid.toString("hex");
      (function(_this) {
        return (function(__iced_k) {
          if (key_manager.pgp != null) {
            if ((existing = _this._kids_to_merged_pgp_key_managers[kid_str]) != null) {
              existing.merge_everything(key_manager);
            } else {
              _this._kids_to_merged_pgp_key_managers[kid_str] = key_manager;
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ParsedKeys._add_key"
              });
              key_manager.pgp_full_hash({}, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return hash = arguments[0];
                  };
                })(),
                lineno: 50
              })));
              __iced_deferrals._fulfill();
            })(function() {
              var _base;
              return __iced_k(((_base = _this._kids_to_pgp_key_managers_by_hash)[kid_str] || (_base[kid_str] = {}))[hash] = key_manager);
            });
          } else {
            return __iced_k(_this._kids_to_nacl_keys[kid_str] = key_manager);
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb();
        };
      })(this));
    };

    ParsedKeys.prototype.get_merged_pgp_key_manager = function(kid) {
      return this._kids_to_merged_pgp_key_managers[kid];
    };

    ParsedKeys.prototype.get_pgp_key_manager_with_hash = function(kid, hash) {
      var _ref1;
      return (_ref1 = this._kids_to_pgp_key_managers_by_hash[kid]) != null ? _ref1[hash] : void 0;
    };

    ParsedKeys.prototype.get_nacl_key_manager = function(kid) {
      return this._kids_to_nacl_keys[kid];
    };

    return ParsedKeys;

  })();

  KeyState = (function() {
    function KeyState(_arg) {
      this.parsed_keys = _arg.parsed_keys;
      this._kid_to_hash = {};
    }

    KeyState.prototype.set_key_hash = function(_arg, cb) {
      var hash, kid;
      kid = _arg.kid, hash = _arg.hash;
      if (this.parsed_keys.get_pgp_key_manager_with_hash(kid, hash) == null) {
        cb(new E.NoKeyWithThisHashError("No PGP key with kid " + kid + " and hash " + hash + " exists"));
      }
      this._kid_to_hash[kid] = hash;
      return cb();
    };

    KeyState.prototype.get_key_manager = function(kid) {
      var hash, key;
      if ((key = this.parsed_keys.get_nacl_key_manager(kid)) != null) {
        return key;
      }
      if ((hash = this._kid_to_hash[kid]) != null) {
        return this.parsed_keys.get_pgp_key_manager_with_hash(kid, hash);
      }
      return this.parsed_keys.get_merged_pgp_key_manager(kid);
    };

    return KeyState;

  })();

  ChainLink = (function() {
    ChainLink.parse = function(_arg, cb) {
      var esc, key_state, payload, payload_hash, sig_blob, sig_cache, sig_id, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, key_state = _arg.key_state, sig_cache = _arg.sig_cache;
      esc = make_esc(cb, "ChainLink.parse");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
            funcname: "ChainLink.parse"
          });
          _this._unbox_payload({
            sig_blob: sig_blob,
            key_state: key_state,
            sig_cache: sig_cache
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                payload = arguments[0];
                sig_id = arguments[1];
                return payload_hash = arguments[2];
              };
            })(),
            lineno: 105
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "ChainLink.parse"
            });
            check_link_payload_format({
              payload: payload
            }, esc(__iced_deferrals.defer({
              lineno: 107
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink.parse"
              });
              _this._check_payload_against_server_kid({
                sig_blob: sig_blob,
                payload: payload,
                key_state: key_state
              }, esc(__iced_deferrals.defer({
                lineno: 110
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ChainLink.parse"
                });
                _this._check_reverse_signatures({
                  payload: payload,
                  key_state: key_state
                }, esc(__iced_deferrals.defer({
                  lineno: 112
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return cb(null, new ChainLink({
                  kid: sig_blob.kid,
                  sig_id: sig_id,
                  payload: payload,
                  payload_hash: payload_hash
                }));
              });
            });
          });
        };
      })(this));
    };

    ChainLink._unbox_payload = function(_arg, cb) {
      var ctime_seconds, err, esc, key_manager, key_state, kid, payload, payload_hash, payload_json, sig_blob, sig_body, sig_cache, sig_eng, sig_id, unverified_buffer, verified_buffer, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, key_state = _arg.key_state, sig_cache = _arg.sig_cache;
      esc = make_esc(cb, "ChainLink._unbox_payload");
      kid = sig_blob.kid;
      key_manager = key_state.get_key_manager(kid);
      (function(_this) {
        return (function(__iced_k) {
          if (key_manager == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink._unbox_payload"
              });
              athrow(new E.NonexistentKidError("link signed by nonexistent kid " + kid), esc(__iced_deferrals.defer({
                lineno: 124
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          sig_eng = key_manager.make_sig_eng();
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "ChainLink._unbox_payload"
            });
            sig_eng.get_body_and_unverified_payload({
              armored: sig_blob.sig
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  sig_body = arguments[0];
                  return unverified_buffer = arguments[1];
                };
              })(),
              lineno: 130
            })));
            __iced_deferrals._fulfill();
          })(function() {
            sig_id = kbpgp.hash.SHA256(sig_body).toString("hex") + SIG_ID_SUFFIX;
            payload_hash = kbpgp.hash.SHA256(unverified_buffer).toString("hex");
            payload_json = unverified_buffer.toString('utf8');
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink._unbox_payload"
              });
              a_json_parse(payload_json, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return payload = arguments[0];
                  };
                })(),
                lineno: 134
              })));
              __iced_deferrals._fulfill();
            })(function() {
              ctime_seconds = payload.ctime;
              (function(__iced_k) {
                if (sig_cache != null) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "ChainLink._unbox_payload"
                    });
                    sig_cache.get({
                      sig_id: sig_id
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return verified_buffer = arguments[0];
                        };
                      })(),
                      lineno: 138
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(function() {
                (function(__iced_k) {
                  if (typeof verified_buffer === "undefined" || verified_buffer === null) {
                    exports.debug.unbox_count++;
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                        funcname: "ChainLink._unbox_payload"
                      });
                      key_manager.make_sig_eng().unbox(sig_blob.sig, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            err = arguments[0];
                            return verified_buffer = arguments[1];
                          };
                        })(),
                        lineno: 143
                      }), {
                        now: ctime_seconds
                      });
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        if (typeof err !== "undefined" && err !== null) {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                              funcname: "ChainLink._unbox_payload"
                            });
                            athrow(new E.VerifyFailedError(err.message), esc(__iced_deferrals.defer({
                              lineno: 146
                            })));
                            __iced_deferrals._fulfill();
                          })(__iced_k);
                        } else {
                          return __iced_k();
                        }
                      })(function() {
                        (function(__iced_k) {
                          if (sig_cache != null) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                                funcname: "ChainLink._unbox_payload"
                              });
                              sig_cache.put({
                                sig_id: sig_id,
                                payload_buffer: verified_buffer
                              }, esc(__iced_deferrals.defer({
                                lineno: 148
                              })));
                              __iced_deferrals._fulfill();
                            })(__iced_k);
                          } else {
                            return __iced_k();
                          }
                        })(__iced_k);
                      });
                    });
                  } else {
                    return __iced_k();
                  }
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "ChainLink._unbox_payload"
                    });
                    check_buffers_equal(verified_buffer, unverified_buffer, esc(__iced_deferrals.defer({
                      lineno: 153
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return cb(null, payload, sig_id, payload_hash);
                  });
                });
              });
            });
          });
        };
      })(this));
    };

    ChainLink._check_payload_against_server_kid = function(_arg, cb) {
      var err, key_state, payload, payload_fingerprint, payload_kid, sig_blob, signing_fingerprint, signing_kid, _ref1;
      sig_blob = _arg.sig_blob, payload = _arg.payload, key_state = _arg.key_state;
      signing_kid = sig_blob.kid;
      signing_fingerprint = (_ref1 = key_state.get_key_manager(signing_kid).get_pgp_fingerprint()) != null ? _ref1.toString('hex') : void 0;
      payload_kid = payload.body.key.kid;
      payload_fingerprint = payload.body.key.fingerprint;
      err = null;
      if ((payload_kid != null) && payload_kid !== signing_kid) {
        err = new E.KidMismatchError("signing kid (" + signing_kid + ") and payload kid (" + payload_kid + ") mismatch");
      } else if ((payload_fingerprint != null) && payload_fingerprint !== signing_fingerprint) {
        err = new E.FingerprintMismatchError("signing fingerprint (" + signing_fingerprint + ") and payload fingerprint (" + payload_fingerprint + ") mismatch");
      }
      return cb(err);
    };

    ChainLink._check_reverse_signatures = function(_arg, cb) {
      var err, esc, full_hash, key_state, kid, payload, sibkey_key_manager, sibkey_proof, subkey_key_manager, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      payload = _arg.payload, key_state = _arg.key_state;
      esc = make_esc(cb, "ChainLink._check_reverse_signatures");
      (function(_this) {
        return (function(__iced_k) {
          if (payload.body.sibkey != null) {
            kid = payload.body.sibkey.kid;
            full_hash = payload.body.sibkey.full_hash;
            sibkey_key_manager = full_hash != null ? key_state.parsed_keys.get_pgp_key_manager_with_hash(kid, full_hash) : key_state.get_key_manager(kid);
            (function(__iced_k) {
              if (sibkey_key_manager == null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "ChainLink._check_reverse_signatures"
                  });
                  athrow(new E.NonexistentKidError("link reverse-signed by nonexistent kid " + kid), esc(__iced_deferrals.defer({
                    lineno: 181
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              sibkey_proof = new proofs.Sibkey({});
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ChainLink._check_reverse_signatures"
                });
                sibkey_proof.reverse_sig_check({
                  json: payload,
                  subkm: sibkey_key_manager
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 183
                }));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  if (typeof err !== "undefined" && err !== null) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                        funcname: "ChainLink._check_reverse_signatures"
                      });
                      athrow(new E.ReverseSigVerifyFailedError(err.message), esc(__iced_deferrals.defer({
                        lineno: 185
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  } else {
                    return __iced_k();
                  }
                })(__iced_k);
              });
            });
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (payload.body.subkey != null) {
              kid = payload.body.subkey.kid;
              subkey_key_manager = key_state.get_key_manager(kid);
              (function(__iced_k) {
                if (subkey_key_manager == null) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "ChainLink._check_reverse_signatures"
                    });
                    athrow(new E.NonexistentKidError("link delegates nonexistent subkey " + kid), esc(__iced_deferrals.defer({
                      lineno: 190
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    function ChainLink(_arg) {
      var _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.kid = _arg.kid, this.sig_id = _arg.sig_id, this.payload = _arg.payload, this.payload_hash = _arg.payload_hash;
      this.uid = this.payload.body.key.uid;
      this.username = this.payload.body.key.username;
      this.seqno = this.payload.seqno;
      this.prev = this.payload.prev;
      this.fingerprint = this.payload.body.key.fingerprint;
      this.eldest_kid = this.payload.body.key.eldest_kid || this.kid;
      this.ctime_seconds = this.payload.ctime;
      this.etime_seconds = this.ctime_seconds + this.payload.expire_in;
      this.signing_key_hash = this.payload.body.key.full_hash;
      this.sibkey_delegation = (_ref1 = this.payload.body.sibkey) != null ? _ref1.kid : void 0;
      this.sibkey_hash = (_ref2 = this.payload.body.sibkey) != null ? _ref2.full_hash : void 0;
      this.subkey_delegation = (_ref3 = this.payload.body.subkey) != null ? _ref3.kid : void 0;
      this.pgp_update_kid = (_ref4 = this.payload.body.pgp_update) != null ? _ref4.kid : void 0;
      this.pgp_update_hash = (_ref5 = this.payload.body.pgp_update) != null ? _ref5.full_hash : void 0;
      this.key_revocations = [];
      if (((_ref6 = this.payload.body.revoke) != null ? _ref6.kids : void 0) != null) {
        this.key_revocations = this.payload.body.revoke.kids;
      }
      if (((_ref7 = this.payload.body.revoke) != null ? _ref7.kid : void 0) != null) {
        this.key_revocations.push(this.payload.body.revoke.kid);
      }
      this.sig_revocations = [];
      if (((_ref8 = this.payload.body.revoke) != null ? _ref8.sig_ids : void 0) != null) {
        this.sig_revocations = this.payload.body.revoke.sig_ids;
      }
      if (((_ref9 = this.payload.body.revoke) != null ? _ref9.sig_id : void 0) != null) {
        this.sig_revocations.push(this.payload.body.revoke.sig_id);
      }
    }

    return ChainLink;

  })();

  exports.check_link_payload_format = check_link_payload_format = function(_arg, cb) {
    var esc, payload, uid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    payload = _arg.payload;
    esc = make_esc(cb, "check_link_payload_format");
    uid = payload.body.key.uid;
    (function(_this) {
      return (function(__iced_k) {
        if (uid.length !== UID_LEN) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced"
            });
            athrow(new E.BadLinkFormatError("UID wrong length: " + uid.length), esc(__iced_deferrals.defer({
              lineno: 235
            })));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      });
    })(this)((function(_this) {
      return function() {
        return cb();
      };
    })(this));
  };

  exports.check_buffers_equal = check_buffers_equal = function(verified_buffer, unverified_buffer, cb) {
    var err, msg;
    err = null;
    if (!bufeq_secure(verified_buffer, unverified_buffer)) {
      msg = "Payload mismatch!\nVerified:\n" + (verified_buffer.toString('hex')) + "\nUnverified:\n" + (unverified_buffer.toString('hex'));
      err = new E.VerifyFailedError(msg);
    }
    return cb(err);
  };

  exports.SigChain = SigChain = (function() {
    SigChain.replay = function(_arg, cb) {
      var eldest_kid, esc, key_state, log, parsed_keys, sig_blob, sig_blobs, sig_cache, sigchain, uid, username, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blobs = _arg.sig_blobs, parsed_keys = _arg.parsed_keys, sig_cache = _arg.sig_cache, uid = _arg.uid, username = _arg.username, eldest_kid = _arg.eldest_kid, log = _arg.log;
      log = log || (function() {});
      log("+ libkeybase: replay(username: " + username + ", uid: " + uid + ", eldest: " + eldest_kid + ")");
      esc = make_esc(cb, "SigChain.replay");
      (function(_this) {
        return (function(__iced_k) {
          if (eldest_kid == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain.replay"
              });
              athrow(new Error("eldest_kid parameter is required"), esc(__iced_deferrals.defer({
                lineno: 284
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          key_state = new KeyState({
            parsed_keys: parsed_keys
          });
          sigchain = new SigChain({
            uid: uid,
            username: username,
            eldest_kid: eldest_kid,
            key_state: key_state
          });
          (function(__iced_k) {
            var _i, _len, _ref1, _results, _while;
            _ref1 = sig_blobs;
            _len = _ref1.length;
            _i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++_i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(_i < _len)) {
                return _break();
              } else {
                sig_blob = _ref1[_i];
                log("| libkeybase: replaying signature " + sig_blob.seqno + ": " + sig_blob.sig_id);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain.replay"
                  });
                  sigchain._add_new_link({
                    sig_blob: sig_blob,
                    sig_cache: sig_cache,
                    log: log
                  }, esc(__iced_deferrals.defer({
                    lineno: 291
                  })));
                  __iced_deferrals._fulfill();
                })(_next);
              }
            };
            _while(__iced_k);
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain.replay"
              });
              sigchain._enforce_eldest_key_ownership({}, esc(__iced_deferrals.defer({
                lineno: 294
              })));
              __iced_deferrals._fulfill();
            })(function() {
              log("- libkeybase: replay finished");
              return cb(null, sigchain);
            });
          });
        };
      })(this));
    };

    function SigChain(_arg) {
      var eldest_kid, key_state, uid, username;
      uid = _arg.uid, username = _arg.username, eldest_kid = _arg.eldest_kid, key_state = _arg.key_state;
      this._uid = uid;
      this._username = username;
      this._eldest_kid = eldest_kid;
      this._key_state = key_state;
      this._links = [];
      this._next_seqno = 1;
      this._next_payload_hash = null;
      this._unrevoked_links = {};
      this._valid_sibkeys = {};
      this._sibkey_order = [eldest_kid];
      this._valid_sibkeys[eldest_kid] = true;
      this._valid_subkeys = {};
      this._subkey_order = [];
      this._eldest_key_delegated = false;
      this._eldest_key_verified = false;
      this._kid_to_etime_seconds = {};
      this._update_kid_pgp_etime({
        kid: eldest_kid
      });
    }

    SigChain.prototype.get_links = function() {
      var link;
      return (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this._links;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          link = _ref1[_i];
          if (link.sig_id in this._unrevoked_links) {
            _results.push(link);
          }
        }
        return _results;
      }).call(this);
    };

    SigChain.prototype.get_sibkeys = function(_arg) {
      var etime, expired, kid, now, ret, _i, _len, _ref1;
      now = _arg.now;
      now = now || current_time_seconds();
      ret = [];
      _ref1 = this._sibkey_order;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        kid = _ref1[_i];
        etime = this._kid_to_etime_seconds[kid];
        expired = (etime != null) && now > etime;
        if (this._valid_sibkeys[kid] && !expired) {
          ret.push(this._key_state.get_key_manager(kid));
        }
      }
      return ret;
    };

    SigChain.prototype.get_subkeys = function(_arg) {
      var etime, expired, kid, now, ret, _i, _len, _ref1;
      now = _arg.now;
      now = now || current_time_seconds();
      ret = [];
      _ref1 = this._subkey_order;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        kid = _ref1[_i];
        etime = this._kid_to_etime_seconds[kid];
        expired = (etime != null) && now > etime;
        if (this._valid_subkeys[kid] && !expired) {
          ret.push(this._key_state.get_key_manager(kid));
        }
      }
      return ret;
    };

    SigChain.prototype._add_new_link = function(_arg, cb) {
      var esc, link, log, sig_blob, sig_cache, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, sig_cache = _arg.sig_cache, log = _arg.log;
      esc = make_esc(cb, "SigChain._add_new_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
            funcname: "SigChain._add_new_link"
          });
          ChainLink.parse({
            sig_blob: sig_blob,
            key_state: _this._key_state,
            sig_cache: sig_cache
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return link = arguments[0];
              };
            })(),
            lineno: 352
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          log("| libkeybase: chain link parsed, type '" + link.payload.body.type + "'");
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "SigChain._add_new_link"
            });
            _this._check_link_belongs_here({
              link: link
            }, esc(__iced_deferrals.defer({
              lineno: 357
            })));
            __iced_deferrals._fulfill();
          })(function() {
            if (link.eldest_kid !== _this._eldest_kid) {
              if (_this._links.length === 0) {
                log("| libkeybase: link not in the current subchain -- skipping ahead");
                cb(null);
                return;
              } else {
                cb(new E.NotLatestSubchainError("Found a later subchain with eldest kid " + link.eldest_kid));
                return;
              }
            }
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain._add_new_link"
              });
              _this._check_key_is_valid({
                link: link
              }, esc(__iced_deferrals.defer({
                lineno: 376
              })));
              __iced_deferrals._fulfill();
            })(function() {
              log("| libkeybase: signing key is valid (" + link.kid + ")");
              _this._links.push(link);
              _this._unrevoked_links[link.sig_id] = link;
              if (link.kid === _this._eldest_kid) {
                _this._eldest_key_verified = true;
              }
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "SigChain._add_new_link"
                });
                _this._delegate_keys({
                  link: link,
                  log: log
                }, esc(__iced_deferrals.defer({
                  lineno: 385
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain._add_new_link"
                  });
                  _this._revoke_keys_and_sigs({
                    link: link,
                    log: log
                  }, esc(__iced_deferrals.defer({
                    lineno: 386
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  return cb(null);
                });
              });
            });
          });
        };
      })(this));
    };

    SigChain.prototype._check_link_belongs_here = function(_arg, cb) {
      var err, link;
      link = _arg.link;
      err = null;
      if (link.uid !== this._uid) {
        err = new E.WrongUidError("Link doesn't refer to the right uid, expected: " + link.uid + " got: " + this._uid);
      } else if (link.username.toLowerCase() !== this._username.toLowerCase()) {
        err = new E.WrongUsernameError("Link doesn't refer to the right username, expected: " + link.username + " got: " + this._username);
      } else if (link.seqno !== this._next_seqno) {
        err = new E.WrongSeqnoError("Link sequence number is wrong, expected: " + this._next_seqno + " got: " + link.seqno);
      } else if ((this._next_payload_hash != null) && link.prev !== this._next_payload_hash) {
        err = new E.WrongPrevError("Previous payload hash doesn't match, expected: " + this._next_payload_hash + " got: " + link.prev);
      }
      this._next_seqno++;
      this._next_payload_hash = link.payload_hash;
      return cb(err);
    };

    SigChain.prototype._check_key_is_valid = function(_arg, cb) {
      var err, kid, link;
      link = _arg.link;
      err = null;
      if (!(link.kid in this._valid_sibkeys)) {
        err = new E.InvalidSibkeyError("not a valid sibkey: " + link.kid + ", valid sibkeys: " + (JSON.stringify((function() {
          var _results;
          _results = [];
          for (kid in this._valid_sibkeys) {
            _results.push(kid);
          }
          return _results;
        }).call(this))));
      } else if (link.ctime_seconds > this._kid_to_etime_seconds[link.kid]) {
        err = new E.ExpiredSibkeyError("expired sibkey: " + link.kid);
      }
      return cb(err);
    };

    SigChain.prototype._delegate_keys = function(_arg, cb) {
      var esc, link, log, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      link = _arg.link, log = _arg.log;
      esc = make_esc(cb, 'SigChain._delegate_keys');
      (function(_this) {
        return (function(__iced_k) {
          if (link.kid === _this._eldest_kid && !_this._eldest_key_delegated) {
            _this._update_kid_etime({
              kid: _this._eldest_kid,
              etime_seconds: link.etime_seconds
            });
            (function(__iced_k) {
              if (link.signing_key_hash != null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain._delegate_keys"
                  });
                  _this._key_state.set_key_hash({
                    kid: _this._eldest_kid,
                    hash: link.signing_key_hash
                  }, esc(__iced_deferrals.defer({
                    lineno: 428
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              return __iced_k(_this._eldest_key_delegated = true);
            });
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (link.sibkey_delegation != null) {
              _this._valid_sibkeys[link.sibkey_delegation] = true;
              (function(__iced_k) {
                if (link.sibkey_hash != null) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "SigChain._delegate_keys"
                    });
                    _this._key_state.set_key_hash({
                      kid: link.sibkey_delegation,
                      hash: link.sibkey_hash
                    }, esc(__iced_deferrals.defer({
                      lineno: 433
                    })));
                    __iced_deferrals._fulfill();
                  })(__iced_k);
                } else {
                  return __iced_k();
                }
              })(function() {
                _this._sibkey_order.push(link.sibkey_delegation);
                _this._update_kid_etime({
                  kid: link.sibkey_delegation,
                  etime_seconds: link.etime_seconds
                });
                _this._update_kid_pgp_etime({
                  kid: link.sibkey_delegation
                });
                return __iced_k(log("| libkeybase: delegating sibkey " + link.sibkey_delegation));
              });
            } else {
              return __iced_k();
            }
          })(function() {
            if (link.subkey_delegation != null) {
              _this._valid_subkeys[link.subkey_delegation] = true;
              _this._subkey_order.push(link.subkey_delegation);
              _this._update_kid_etime({
                kid: link.subkey_delegation,
                etime_seconds: link.etime_seconds
              });
            }
            (function(__iced_k) {
              if ((link.pgp_update_kid != null) && (link.pgp_update_hash != null) && (_this._valid_sibkeys[link.pgp_update_kid] != null)) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain._delegate_keys"
                  });
                  _this._key_state.set_key_hash({
                    kid: link.pgp_update_kid,
                    hash: link.pgp_update_hash
                  }, esc(__iced_deferrals.defer({
                    lineno: 444
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              return cb();
            });
          });
        };
      })(this));
    };

    SigChain.prototype._update_kid_pgp_etime = function(_arg) {
      var etime_seconds, key_manager, kid, lifespan, _ref1;
      kid = _arg.kid;
      key_manager = this._key_state.get_key_manager(kid);
      lifespan = key_manager != null ? (_ref1 = key_manager.primary) != null ? _ref1.lifespan : void 0 : void 0;
      if ((lifespan != null ? lifespan.expire_in : void 0) != null) {
        etime_seconds = lifespan.generated + lifespan.expire_in;
        return this._update_kid_etime({
          kid: kid,
          etime_seconds: etime_seconds
        });
      }
    };

    SigChain.prototype._update_kid_etime = function(_arg) {
      var etime_seconds, kid;
      kid = _arg.kid, etime_seconds = _arg.etime_seconds;
      if (this._kid_to_etime_seconds[kid] == null) {
        return this._kid_to_etime_seconds[kid] = etime_seconds;
      } else {
        return this._kid_to_etime_seconds[kid] = Math.min(etime_seconds, this._kid_to_etime_seconds[kid]);
      }
    };

    SigChain.prototype._revoke_keys_and_sigs = function(_arg, cb) {
      var kid, link, log, revoked_link, revoked_sibkey, revoked_subkey, sig_id, _i, _j, _len, _len1, _ref1, _ref2;
      link = _arg.link, log = _arg.log;
      _ref1 = link.key_revocations;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        kid = _ref1[_i];
        if (kid in this._valid_sibkeys) {
          log("| libkeybase: revoking sibkey " + kid);
          delete this._valid_sibkeys[kid];
        }
        if (kid in this._valid_subkeys) {
          delete this._valid_subkeys[kid];
        }
      }
      _ref2 = link.sig_revocations;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        sig_id = _ref2[_j];
        if (sig_id in this._unrevoked_links) {
          revoked_link = this._unrevoked_links[sig_id];
          delete this._unrevoked_links[sig_id];
          revoked_sibkey = revoked_link.sibkey_delegation;
          if ((revoked_sibkey != null) && revoked_sibkey in this._valid_sibkeys) {
            log("| libkeybase: revoking sibkey " + revoked_sibkey + " from sig " + sig_id);
            delete this._valid_sibkeys[revoked_sibkey];
          }
          revoked_subkey = revoked_link.subkey_delegation;
          if ((revoked_subkey != null) && revoked_subkey in this._valid_subkeys) {
            delete this._valid_subkeys[revoked_subkey];
          }
        }
      }
      return cb();
    };

    SigChain.prototype._enforce_eldest_key_ownership = function(_arg, cb) {
      var eldest_km, esc, expected_email, identity, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      _arg;
      esc = make_esc(cb, "SigChain._enforce_eldest_key_ownership");
      if (this._eldest_key_verified) {
        cb(null);
        return;
      }
      eldest_km = this._key_state.get_key_manager(this._eldest_kid);
      (function(_this) {
        return (function(__iced_k) {
          if (eldest_km == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain._enforce_eldest_key_ownership"
              });
              athrow(new E.NonexistentKidError("no key for eldest kid " + _this._eldest_kid), esc(__iced_deferrals.defer({
                lineno: 505
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          userids = eldest_km.get_userids_mark_primary();
          (function(__iced_k) {
            if (userids == null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "SigChain._enforce_eldest_key_ownership"
                });
                athrow(new E.KeyOwnershipError("key " + _this._eldest_kid + " is not self-signing"), esc(__iced_deferrals.defer({
                  lineno: 510
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            var _i, _len;
            expected_email = _this._username + "@keybase.io";
            for (_i = 0, _len = userids.length; _i < _len; _i++) {
              identity = userids[_i];
              if (identity.get_email() === expected_email) {
                cb(null);
                return;
              }
            }
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/sidney/src/keybase/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "SigChain._enforce_eldest_key_ownership"
            });
            athrow(new E.KeyOwnershipError("key " + _this._eldest_kid + " is not owned by " + expected_email), esc(__iced_deferrals.defer({
              lineno: 518
            })));
            __iced_deferrals._fulfill();
          });
        };
      })(this));
    };

    return SigChain;

  })();

  error_names = ["BAD_LINK_FORMAT", "EXPIRED_SIBKEY", "FINGERPRINT_MISMATCH", "INVALID_SIBKEY", "KEY_OWNERSHIP", "KID_MISMATCH", "NO_KEY_WITH_THIS_HASH", "NONEXISTENT_KID", "NOT_LATEST_SUBCHAIN", "REVERSE_SIG_VERIFY_FAILED", "VERIFY_FAILED", "WRONG_UID", "WRONG_USERNAME", "WRONG_SEQNO", "WRONG_PREV"];

  errors_map = {};

  for (_i = 0, _len = error_names.length; _i < _len; _i++) {
    name = error_names[_i];
    errors_map[name] = "";
  }

  exports.E = E = ie.make_errors(errors_map);

  current_time_seconds = function() {
    return Math.floor(new Date().getTime() / 1000);
  };

  __iced_k_noop();

}).call(this);
