// Generated by IcedCoffeeScript 1.6.3-j
(function() {
  var KeyGen, PackageJson, constants, env, iced, init, init_env, make_esc, master_ring, test, __iced_k, __iced_k_noop, _ref, _ref1;

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  constants = require('./constants').constants;

  make_esc = require('iced-error').make_esc;

  PackageJson = require('./package').PackageJson;

  _ref = require('./keyring'), init = _ref.init, master_ring = _ref.master_ring;

  _ref1 = require('./env'), env = _ref1.env, init_env = _ref1.init_env;

  exports.KeyGen = KeyGen = (function() {
    function KeyGen(_arg) {
      this.username = _arg.username, this.config = _arg.config, this.passphrase = _arg.passphrase, this.ring = _arg.ring;
      this.ring || (this.ring = master_ring());
      this.key = null;
    }

    KeyGen.prototype.gen = function(cb) {
      var args, email, esc, h, script, stdin, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "KeyGen::Gen");
      h = constants.canonical_host;
      email = this.username + ("@" + h);
      script = ["%echo generating", "Key-Type: RSA", "Key-Length: " + this.config.master.bits, "Subkey-Type: RSA", "Subkey-Length: " + this.config.subkey.bits, "Name-Real: " + h + "/" + this.username, "Name-Comment: " + ((new PackageJson).identify_as()), "Name-Email: " + email, "Expire-date: " + this.config.expire, "Passphrase: " + this.passphrase, "%commit"];
      stdin = script.join("\n");
      args = ["--batch", "--gen-key"];
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase-node-client/src/keygen.iced",
            funcname: "KeyGen.gen"
          });
          _this.ring.gpg({
            args: args,
            stdin: stdin,
            quiet: false
          }, esc(__iced_deferrals.defer({
            lineno: 38
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this.key = _this.ring.make_key({
            username: "<" + email + ">",
            secret: true
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/max/src/keybase-node-client/src/keygen.iced",
              funcname: "KeyGen.gen"
            });
            _this.key.load(esc(__iced_deferrals.defer({
              lineno: 40
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        };
      })(this));
    };

    KeyGen.prototype.encrypt_to_p3skb = function(cb) {
      var Encryptor, KeyManager, esc, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      KeyManager = require('kbpgp').KeyManager;
      Encryptor = require('triplesec').Encryptor;
      esc = make_esc(cb, "KeyGen::encrypt_to_p3skb");
      raw = this.key.key_data().toString('utf8');
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase-node-client/src/keygen.iced",
            funcname: "KeyGen.encrypt_to_p3skb"
          });
          KeyManager.import_from_armored_pgp({
            raw: raw
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.km = arguments[0];
              };
            })(_this),
            lineno: 50
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/max/src/keybase-node-client/src/keygen.iced",
              funcname: "KeyGen.encrypt_to_p3skb"
            });
            _this.km.unlock_pgp({
              passphrase: _this.passphrase
            }, esc(__iced_deferrals.defer({
              lineno: 51
            })));
            __iced_deferrals._fulfill();
          })(function() {
            _this.tsenc = new Encryptor({
              key: new Buffer(_this.passphrase, 'utf8')
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase-node-client/src/keygen.iced",
                funcname: "KeyGen.encrypt_to_p3skb"
              });
              _this.km.sign({}, esc(__iced_deferrals.defer({
                lineno: 53
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/max/src/keybase-node-client/src/keygen.iced",
                  funcname: "KeyGen.encrypt_to_p3skb"
                });
                _this.km.export_private_to_server({
                  tsenc: _this.tsenc
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function(__slot_1) {
                    return function() {
                      return __slot_1.p3skb = arguments[0];
                    };
                  })(_this),
                  lineno: 54
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return cb(null, _this.p3skb);
              });
            });
          });
        };
      })(this));
    };

    return KeyGen;

  })();

  test = function(cb) {
    var err, kg, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    init_env();
    env().set_argv({});
    init();
    kg = new KeyGen({
      username: "tacotime",
      config: constants.keygen,
      passphrase: "now is the time for all men"
    });
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/home/max/src/keybase-node-client/src/keygen.iced"
        });
        kg.gen(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 68
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        console.log(err);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase-node-client/src/keygen.iced"
          });
          kg.encrypt_to_p3skb(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 70
          }));
          __iced_deferrals._fulfill();
        })(function() {
          console.log(err);
          console.log(kg.p3skb);
          return cb();
        });
      };
    })(this));
  };

}).call(this);
