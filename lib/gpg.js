// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var E, GPG, env, iced, log, util, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  GPG = require('gpg-wrapper').GPG;

  env = require('./env').env;

  log = require('./log');

  util = require('util');

  E = require('./err').E;

  exports.gpg = function(inargs, cb) {
    var err, gpg, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    log.debug("| Call to gpg: " + (util.inspect(inargs)));
    if (inargs.quiet && env().get_debug()) {
      inargs.quiet = false;
    }
    gpg = new GPG;
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase/node-client/src/gpg.iced",
          funcname: "gpg"
        });
        gpg.run(inargs, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return out = arguments[1];
            };
          })(),
          lineno: 13
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        return cb(err, out);
      };
    })(this));
  };

  exports.parse_signature = function(lines) {
    var ends_in, err, m, ret, rxx, strip, timestamp;
    strip = function(m) {
      if (m != null) {
        return m.split(/\s+/).join('');
      } else {
        return null;
      }
    };
    ends_in = function(a, b) {
      return a.slice(-b.length) === b;
    };
    rxx = /(?:^|\n)gpg:\sSignature\smade\s(.*?)\ngpg:\s+using\s[RD]SA\skey\s([A-F0-9]{16})\n(?:.*\n)*gpg:\sGood\ssignature\sfrom.*\n(?:.*\n)*Primary\skey\sfingerprint:\s([A-F0-9\s]+)\n(?:\s+Subkey\sfingerprint:\s([A-F0-9\s]+)\n)?/;
    err = ret = null;
    if ((m = lines.match(rxx)) == null) {
      err = new E.NotFoundError("no signature found");
    } else {
      timestamp = new Date(m[1]);
      if (isNaN(timestamp.getTime())) {
        log.info("Invalid date in signature: " + m[1]);
        timestamp = null;
      }
      ret = {
        primary: strip(m[3]),
        subkey: strip(m[4]),
        timestamp: timestamp
      };
      if (!(ends_in(ret.primary, m[2]) || ends_in(ret.subkey, m[2]))) {
        err = new E.VerifyError("key ID didn't match fingerprint");
        ret = null;
      }
    }
    return [err, ret];
  };

}).call(this);
