// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var E, ST, Track, constants, db, deq, iced, log, proof_type_to_string, unix_time, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  db = require('./db').db;

  constants = require('./constants').constants;

  log = require('./log');

  proof_type_to_string = require('keybase-proofs').proof_type_to_string;

  ST = constants.signature_types;

  deq = require('deep-equal');

  E = require('./err').E;

  unix_time = require('pgp-utils').util.unix_time;

  exports.Track = Track = (function() {
    function Track(_arg) {
      this.trackee = _arg.trackee, this.local = _arg.local, this.remote = _arg.remote;
      this.uid = this.trackee.id;
      this.sig_chain = this.trackee.sig_chain;
    }

    Track.prototype.last = function() {
      return this.sig_chain.last();
    };

    Track.prototype.table = function() {
      return this.sig_chain.table[ST.REMOTE_PROOF];
    };

    Track.prototype._check_remote_proof = function(rp) {
      var a, b, link, rkp, _ref, _ref1;
      if ((rkp = rp.remote_key_proof) == null) {
        return new E.RemoteProofError("no 'remote_key_proof field'");
      } else if ((a = (_ref = rkp.check_data_json) != null ? _ref.name : void 0) !== (b = proof_type_to_string[rkp.proof_type])) {
        return new E.RemoteProofError("name mismatch: " + a + " != " + b);
      } else if ((link = this.sig_chain.lookup(rp.curr)) == null) {
        return new E.RemoteProofError("Failed to find a chain link for " + rp.curr);
      } else if (!deq((a = (_ref1 = link.body()) != null ? _ref1.service : void 0), (b = rkp.check_data_json))) {
        log.info("JSON obj mismatch: " + (JSON.stringify(a)) + " != " + (JSON.stringify(b)));
        return new E.RemoteProofError("The check data was wrong for the signature");
      } else {
        return null;
      }
    };

    Track.prototype._check_track_obj = function(o) {
      var a, b, err, rp, _i, _len, _ref, _ref1;
      err = null;
      if ((a = o.id) !== (b = this.trackee.id)) {
        err = new E.UidMismatchError("" + a + " != " + b);
      } else if ((a = (_ref = o.basics) != null ? _ref.username : void 0) !== (b = this.trackee.username())) {
        err = new E.UsernameMismatchError("" + a + " != " + b);
      } else {
        _ref1 = o.remote_proofs;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          rp = _ref1[_i];
          if (err == null) {
            err = this._check_remote_proof(rp);
          }
        }
      }
      return err;
    };

    Track.prototype._skip_remote_check = function(which) {
      var a, b, last, last_check, prob, ret, rpri, track_cert, _check_all_proofs_ok, _ref;
      track_cert = this[which];
      log.debug("+ _skip_remote_check for " + which);
      rpri = constants.time.remote_proof_recheck_interval;
      _check_all_proofs_ok = function(proofs) {
        var proof, _i, _len, _ref;
        for (_i = 0, _len = proofs.length; _i < _len; _i++) {
          proof = proofs[_i];
          if (((_ref = proof.remote_key_proof) != null ? _ref.state : void 0) !== 1) {
            return false;
          }
        }
        return true;
      };
      prob = track_cert == null ? "no track cert given" : (last = this.last()) == null ? "no last link found" : (last_check = track_cert.ctime) != null ? "no last_check" : unix_time() - last_check > rpri ? "timed out!" : (a = (_ref = track_cert.seq_tail) != null ? _ref.payload_hash : void 0) !== (b = last.id) ? "id/hash mismatch: " + a + " != " + b : !(_check_all_proofs_ok(track_cert.remote_proofs)) ? "all proofs were not OK" : void 0;
      ret = prob != null ? (log.debug("| problem: " + prob), false) : true;
      log.debug("- _skip_remote_check -> " + ret);
      return ret;
    };

    Track.prototype._skip_approval = function(which) {
      var a, b, dlen, prob, ret, rkp, rp, tmp, track_cert;
      track_cert = this[which];
      log.debug("+ skip_approval(" + which + ")");
      dlen = function(d) {
        return Object.keys(d).length;
      };
      prob = (function() {
        var _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        if (track_cert == null) {
          return "no cert found";
        } else if ((a = (_ref = track_cert.key) != null ? (_ref1 = _ref.key_fingerprint) != null ? _ref1.toLowerCase() : void 0 : void 0) !== (b = (_ref2 = this.trackee.fingerprint) != null ? _ref2.toLowerCase() : void 0)) {
          return "trackee changed keys: " + a + " != " + b;
        } else if ((a = track_cert.remote_proofs.length) !== (b = dlen(this.table()))) {
          return "number of remote IDs changed: " + a + " != " + b;
        } else {
          tmp = null;
          _ref3 = track_cert.remote_proofs;
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            rp = _ref3[_i];
            rkp = rp.remote_key_proof;
            if (!deq((a = rkp.check_data_json), (b = (_ref4 = this.table()[rkp.proof_type]) != null ? (_ref5 = _ref4.body()) != null ? _ref5.service : void 0 : void 0))) {
              tmp = "Remote ID changed: " + (JSON.stringify(a)) + " != " + (JSON.stringify(b));
              break;
            }
          }
          return tmp;
        }
      }).call(this);
      ret = true;
      if (prob != null) {
        log.debug("| failure: " + prob);
        ret = false;
      }
      log.debug("- skip_approval(" + which + ") -> " + ret);
      return ret;
    };

    Track.prototype.skip_remote_check = function() {
      return (this._skip_remote_check('local')) || (this._skip_remote_check('remote'));
    };

    Track.prototype.skip_approval = function() {
      return (this._skip_approval('local')) || (this._skip_approval('remote'));
    };

    Track.prototype.load_local = function(cb) {
      var err, value, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      log.debug("+ getting local tracking info from DB");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/track.iced",
          funcname: "Track.load_local"
        });
        db.get({
          type: constants.ids.local_track,
          key: _this.uid
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return value = arguments[1];
            };
          })(),
          lineno: 129
        }));
        __iced_deferrals._fulfill();
      })(function() {
        _this.local = value;
        log.debug("- completed, with result: " + (!!value));
        return cb(err);
      });
    };

    Track.prototype.check = function() {
      var e;
      if (this.local) {
        if ((e = this._check_track_obj(this.local)) != null) {
          log.warn("Local tracking object was invalid: " + e.message);
          this.local = null;
        } else {
          log.debug("| local track checked out");
        }
      }
      if (this.remote != null) {
        if ((e = this._check_track_obj(this.remote)) != null) {
          log.warn("Remote tracking object was invalid: " + e.message);
          return this.remote = null;
        } else {
          return log.debug("| remote track checked out");
        }
      }
    };

    Track.load = function(_arg, cb) {
      var err, remote, track, trackee, tracker, uid, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      tracker = _arg.tracker, trackee = _arg.trackee;
      uid = trackee.id;
      remote = tracker != null ? (_ref = tracker.sig_chain) != null ? _ref.get_track_obj(uid) : void 0 : void 0;
      log.debug("+ loading Tracking info w/ remote=" + (!!remote));
      track = new Track({
        uid: uid,
        trackee: trackee,
        remote: remote
      });
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/track.iced",
          funcname: "Track.load"
        });
        track.load_local(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 157
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (typeof err !== "undefined" && err !== null) {
          track = null;
        }
        if (track != null) {
          track.check();
        }
        log.debug("- loaded tracking info");
        return cb(err, track);
      });
    };

    return Track;

  })();

}).call(this);
