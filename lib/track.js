// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ST, Track, constants, db, deq, iced, log, proof_type_to_string, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  db = require('./db').db;

  constants = require('./constants').constants;

  log = require('./log');

  proof_type_to_string = require('keybase-proofs').proof_type_to_string;

  ST = constants.signature_types;

  deq = require('deep-equal');

  exports.Track = Track = (function() {
    function Track(_arg) {
      this.trackee = _arg.trackee, this.local = _arg.local, this.remote = _arg.remote;
      this.uid = this.trackee.id;
      this.sig_chain = this.trackee.sig_chain;
    }

    Track.prototype.last = function() {
      return this.sig_chain.last();
    };

    Track.prototype.table = function() {
      return this.sig_chain.table[ST.REMOTE_PROOF];
    };

    Track.prototype._check_remote_proof = function(rp) {
      var a, b, link, rkp, _ref, _ref1, _ref2;
      if ((rkp = rp.remote_key_proof) == null) {
        return new E.RemoteProofError("no 'remote_key_proof field'");
      } else if ((a = (_ref = rkp.check_data_json) != null ? _ref.name : void 0) !== (b = proof_type_to_string(rkp.proof_type))) {
        return new E.RemoteProofError("name mismatch: " + a + " != " + b);
      } else if ((link = this.sig_chain.lookup[rp.curr]) == null) {
        return new E.RemoteProofError("Failed to find a chain link for " + rp.curr);
      } else if (!deq((_ref1 = link.payload_json()) != null ? (_ref2 = _ref1.body) != null ? _ref2.service : void 0 : void 0, rkp.check_json_data)) {
        return new E.RemoteProofError("The check data was wrong for the signature");
      } else {
        return null;
      }
    };

    Track.prototype._check_track_obj = function(o) {
      var a, b, err, rp, _i, _len, _ref, _ref1;
      err = null;
      if ((a = o.id) !== (b = this.trackee.id)) {
        err = new E.UidMismatch("" + a + " != " + b);
      } else if ((a = (_ref = o.basics) != null ? _ref.username : void 0) !== (b = this.trackee.username())) {
        err = new E.UsernameMismatch("" + a + " != " + b);
      } else {
        _ref1 = o.remote_proofs;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          rp = _ref1[_i];
          if (err == null) {
            err = this._check_remote_proof(rp);
          }
        }
      }
      return err;
    };

    Track.prototype._skip_remote_check = function(track_cert) {
      var last, last_change, last_check, rpri, _check_all_proofs_ok, _ref;
      rpri = constants.time.remote_proof_recheck_interval;
      _check_all_proofs_ok = function(proofs) {
        var proof, _i, _len, _ref;
        for (_i = 0, _len = proofs.length; _i < _len; _i++) {
          proof = proofs[_i];
          if (((_ref = proof.remote_key_proof) != null ? _ref.state : void 0) !== 1) {
            return false;
          }
        }
        return true;
      };
      return (track_cert != null) && (last = this.last() != null) && ((last_check = last != null ? last.ctime : void 0) != null) && ((last_change = track_cert.ctime) != null) && (last_check - last_change > rpri) && (((_ref = track_cert.seq_tail) != null ? _ref.payload_hash : void 0) === last.id) && (_check_all_proofs_ok(track_cert.remote_proofs));
    };

    Track.prototype._skip_approval = function(track_cert) {
      var dlen, ret, rkp, rp, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      dlen = function(d) {
        return Object.keys(d).length;
      };
      if (track_cert == null) {
        return false;
      } else if (((_ref = track_cert.key) != null ? _ref.key_fingerprint : void 0) !== this.trackee.fingerprint) {
        return false;
      } else if (track_cert.remote_proofs.length !== dlen(this.table())) {
        return false;
      } else {
        ret = true;
        _ref1 = track_cert.remote_proofs;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          rp = _ref1[_i];
          rkp = rp.remote_key_proof;
          if (!deq(rkp.check_json_data, (_ref2 = this.table()[rkp.proof_type]) != null ? (_ref3 = _ref2.payload_json()) != null ? (_ref4 = _ref3.body) != null ? _ref4.service : void 0 : void 0 : void 0)) {
            ret = false;
            break;
          }
        }
        return ret;
      }
    };

    Track.prototype.skip_remote_check = function() {
      return (this._skip_remote_check(this.local)) || (this._skip_remote_check(this.remote));
    };

    Track.prototype.skip_approval = function() {
      return (this._skip_approval(this.local)) || (this._skip_approval(this.remote));
    };

    Track.prototype.load_local = function(cb) {
      var err, value, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      log.debug("+ getting local tracking info from DB");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/track.iced",
          funcname: "Track.load_local"
        });
        db.get({
          type: constants.ids.local_track,
          key: _this.uid
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return value = arguments[1];
            };
          })(),
          lineno: 99
        }));
        __iced_deferrals._fulfill();
      })(function() {
        _this.local = value;
        log.debug("- completed, with result: " + (!!value));
        return cb(err);
      });
    };

    Track.prototype.check = function() {
      var e;
      if (this.local && ((e = this._check_track_obj(this.local)) != null)) {
        log.warn("Local tracking object was invalid: " + e.message);
        this.local = null;
      }
      if ((this.remote != null) && ((e = this._check_track_obj(this.remote)) != null)) {
        log.warn("Remote tracking object was invalid: " + e.message);
        return this.remote = null;
      }
    };

    Track.load = function(_arg, cb) {
      var err, remote, track, trackee, tracker, uid, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      tracker = _arg.tracker, trackee = _arg.trackee;
      log.debug("+ loading Tracking info w/ remote=" + (!!remote));
      uid = trackee.id;
      remote = tracker != null ? (_ref = tracker.sig_chain) != null ? _ref.get_track(uid) : void 0 : void 0;
      track = new Track({
        uid: uid,
        trackee: trackee,
        remote: remote
      });
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/track.iced",
          funcname: "Track.load"
        });
        track.load_local(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 121
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (typeof err !== "undefined" && err !== null) {
          track = null;
        }
        if (track != null) {
          track.check();
        }
        log.debug("- loaded tracking info");
        return cb(err, track);
      });
    };

    return Track;

  })();

}).call(this);
