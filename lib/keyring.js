// Generated by IcedCoffeeScript 1.7.1-a
(function() {
  var E, GE, GpgKey, env, iced, k, keyring, log, v, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  log = require('./log');

  env = require('./env').env;

  _ref = require('./err'), E = _ref.E, GE = _ref.GE;

  keyring = require('gpg-wrapper').keyring;

  GpgKey = (function(_super) {
    __extends(GpgKey, _super);

    function GpgKey() {
      return GpgKey.__super__.constructor.apply(this, arguments);
    }

    GpgKey.prototype.find = function(cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/node-client/src/keyring.iced",
            funcname: "GpgKey.find"
          });
          GpgKey.__super__.find.call(_this, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 13
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          err = err == null ? null : err instanceof GE.NotFoundError ? new E.NoLocalKeyError((_this._is_self ? "You don't have a local " + (_this._secret ? 'secret' : 'public') + " key!" : "the user " + (_this.username()) + " doesn't have a local key")) : err instanceof GE.NoFingerprintError ? new E.NoRemoteKeyError((_this._is_self ? "You don't have a registered remote key! Try `keybase push`" : "the user " + (_this.username()) + " doesn't have a remote key")) : err;
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.has_canonical_username = function() {
      var all_uids, e, em, uid;
      em = env().keybase_email();
      all_uids = this.all_uids();
      return (__indexOf.call((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = all_uids.length; _i < _len; _i++) {
          uid = all_uids[_i];
          if ((e = uid != null ? uid.email : void 0)) {
            _results.push(e);
          }
        }
        return _results;
      })(), em) >= 0);
    };

    GpgKey.make_from_user = function(_arg) {
      var keyring, secret, user, _ref1, _ref2;
      user = _arg.user, secret = _arg.secret, keyring = _arg.keyring;
      return new GpgKey({
        user: user,
        secret: secret,
        username: user.username(),
        is_self: user.is_self(),
        uid: user.id,
        key_data: user != null ? (_ref1 = user.public_keys) != null ? (_ref2 = _ref1.primary) != null ? _ref2.bundle : void 0 : void 0 : void 0,
        keyring: keyring,
        fingerprint: user.fingerprint(true)
      });
    };

    return GpgKey;

  })(keyring.GpgKey);

  for (k in keyring) {
    v = keyring[k];
    exports[k] = v;
  }

  exports.BaseKeyRing.prototype.make_key_from_user = function(user, secret) {
    return GpgKey.make_from_user({
      user: user,
      secret: secret,
      keyring: this
    });
  };

  exports.init = function() {
    return keyring.init({
      get_preserve_tmp_keyring: function() {
        return env().get_preserve_tmp_keyring();
      },
      get_debug: function() {
        return env().get_debug();
      },
      get_tmp_keyring_dir: function() {
        return env().get_tmp_keyring_dir();
      },
      get_key_klass: function() {
        return GpgKey;
      },
      get_home_dir: function() {
        return env().get_home_gnupg_dir(true);
      },
      get_gpg_cmd: function() {
        return env().get_gpg_cmd();
      },
      log: log
    });
  };

}).call(this);
