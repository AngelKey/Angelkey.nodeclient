// Generated by IcedCoffeeScript 1.6.3-j
(function() {
  var BaseKeyRing, BufferOutStream, E, GE, GPG, GpgKey, MasterKeyRing, TmpKeyRing, base64u, colgrep, constants, db, env, fs, gpg, iced, log, make_esc, master_ring, mkdirp, path, prng, strip, util, __iced_k, __iced_k_noop, _mring, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  db = require('./db').db;

  gpg = require('./gpg').gpg;

  log = require('./log');

  constants = require('./constants').constants;

  make_esc = require('iced-error').make_esc;

  mkdirp = require('mkdirp');

  env = require('./env').env;

  prng = require('crypto').prng;

  base64u = require('pgp-utils').util.base64u;

  _ref = require('./err'), GE = _ref.GE, E = _ref.E;

  path = require('path');

  fs = require('fs');

  _ref1 = require('gpg-wrapper'), BufferOutStream = _ref1.BufferOutStream, GPG = _ref1.GPG, colgrep = _ref1.colgrep;

  util = require('util');

  strip = function(m) {
    return m.split(/\s+/).join('');
  };

  GpgKey = (function() {
    function GpgKey(fields) {
      var k, v;
      for (k in fields) {
        v = fields[k];
        this["_" + k] = v;
      }
    }

    GpgKey.prototype.fingerprint = function() {
      return this._fingerprint;
    };

    GpgKey.prototype.key_id_64 = function() {
      return this._key_id_64 || this.fingerprint().slice(-16);
    };

    GpgKey.prototype.load_id = function() {
      return this.key_id_64() || this.fingerprint();
    };

    GpgKey.prototype.username = function() {
      return this._username;
    };

    GpgKey.prototype.uid = function() {
      return this._uid;
    };

    GpgKey.prototype.key_data = function() {
      return this._key_data;
    };

    GpgKey.prototype.keyring = function() {
      return this._keyring;
    };

    GpgKey.prototype.get_pgp_key_id = function() {
      return this.key_id_64();
    };

    GpgKey.prototype.get_pgp_fingerprint = function() {
      return this.fingerprint().toLowerCase();
    };

    GpgKey.prototype.find = function(cb) {
      var args, err, fp, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          if ((fp = _this.fingerprint()) != null) {
            args = ["-" + (_this._secret ? 'K' : 'k'), "--with-colons", fp];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                funcname: "GpgKey.find"
              });
              _this.gpg({
                args: args,
                quiet: true
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return out = arguments[1];
                  };
                })(),
                lineno: 63
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(typeof err !== "undefined" && err !== null ? err = new E.NoLocalKeyError((_this._is_self ? "You don't have a local key!" : "the user " + _this._username + " doesn't have a local key")) : void 0);
            });
          } else {
            return __iced_k(err = new E.NoRemoteKeyError((_this._is_self ? "You don't have a registered remote key! Try `keybase push`" : "the user " + _this._username + " doesn't have a remote key")));
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.check_sig = function(signing_key, cb) {
      var args, err, out, rows, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = ['--list-sigs', '--with-colon', this.fingerprint()];
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "GpgKey.check_sig"
          });
          _this.gpg({
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return out = arguments[1];
              };
            })(),
            lineno: 81
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            rows = colgrep({
              buffer: out,
              patterns: {
                0: /^sub$/,
                4: new RegExp("^" + (signing_key.key_id_64()) + "$", "i")
              }
            });
            if (rows.length === 0) {
              err = new E.VerifyError("No signature of " + (_this.to_string()) + " by " + (signing_key.to_string()));
            }
          }
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.to_string = function() {
      return [this.username(), this.key_id_64()].join("/");
    };

    GpgKey.prototype.gpg = function(gargs, cb) {
      return this.keyring().gpg(gargs, cb);
    };

    GpgKey.prototype.save = function(cb) {
      var args, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = ["--import"];
      log.debug("| Save key " + (this.to_string()) + " to " + (this.keyring().to_string()));
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "GpgKey.save"
          });
          _this.gpg({
            args: args,
            stdin: _this._key_data,
            quiet: true
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 106
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.load = function(cb) {
      var args, err, esc, id, out, rows, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      id = this.load_id();
      esc = make_esc(cb, "GpgKey::load");
      args = [(this._secret ? "--export-secret-key" : "--export"), "--export-options", "export-local-sigs", "-a", id];
      log.debug("| Load key " + (this.to_string()) + " from " + (this.keyring().to_string()) + " (secret=" + this._secret + ")");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "GpgKey.load"
          });
          _this.gpg({
            args: args
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1._key_data = arguments[0];
              };
            })(_this),
            lineno: 122
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (_this.fingerprint() == null) {
              log.debug("+ lookup fingerprint");
              args = ["-k", "--fingerprint", "--with-colons", id];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                  funcname: "GpgKey.load"
                });
                _this.gpg({
                  args: args
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return out = arguments[0];
                    };
                  })(),
                  lineno: 126
                })));
                __iced_deferrals._fulfill();
              })(function() {
                rows = colgrep({
                  buffer: out,
                  patterns: {
                    0: /^fpr$/
                  }
                });
                return __iced_k((rows.length === 0) || ((_this._fingerprint = rows[0][9]) == null) ? err = new GE.GpgError("Couldn't find GPG fingerprint for " + id) : log.debug("- Map " + id + " -> " + _this._fingerprint + " via gpg"));
              });
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(err);
          });
        };
      })(this));
    };

    GpgKey.prototype.remove = function(cb) {
      var args, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = [(this._secret ? "--delete-secret-and-public-key" : "--delete-keys"), "--batch", "--yes", this.fingerprint()];
      log.debug("| Delete key " + (this.to_string()) + " from " + (this.keyring().to_string()));
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "GpgKey.remove"
          });
          _this.gpg({
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 145
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.read_uids_from_key = function(cb) {
      var args, err, uids, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = {
        fingerprint: this.fingerprint()
      };
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "GpgKey.read_uids_from_key"
          });
          _this.keyring().read_uids_from_key(args, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return uids = arguments[1];
              };
            })(),
            lineno: 153
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, uids);
        };
      })(this));
    };

    GpgKey.prototype.sign_key = function(signer, cb) {
      var args, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      log.debug("| GPG-signing " + (this.username()) + "'s key with your key");
      args = ["-u", signer.fingerprint(), "--sign-key", "--batch", "--yes", this.fingerprint()];
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "GpgKey.sign_key"
          });
          _this.gpg({
            args: args,
            quiet: true
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 161
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.commit = function(signer, cb) {
      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "GpgKey::commit");
      (function(_this) {
        return (function(__iced_k) {
          if (_this.keyring().is_temporary()) {
            log.debug("+ " + (_this.to_string()) + ": Commit temporary key");
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                funcname: "GpgKey.commit"
              });
              _this.sign_key(signer, esc(__iced_deferrals.defer({
                lineno: 171
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                  funcname: "GpgKey.commit"
                });
                _this.load(esc(__iced_deferrals.defer({
                  lineno: 172
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                    funcname: "GpgKey.commit"
                  });
                  _this.remove(esc(__iced_deferrals.defer({
                    lineno: 173
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                      funcname: "GpgKey.commit"
                    });
                    (_this.copy_to_keyring(master_ring())).save(esc(__iced_deferrals.defer({
                      lineno: 174
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(log.debug("- " + (_this.to_string()) + ": Commit temporary key"));
                  });
                });
              });
            });
          } else {
            return __iced_k(log.debug("| " + (_this.to_string()) + ": key was previously commited; noop"));
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    GpgKey.prototype.rollback = function(cb) {
      var err, s, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      s = this.to_string();
      err = null;
      (function(_this) {
        return (function(__iced_k) {
          if (env().get_preserve_tmp_keyring() && _this.keyring().is_temporary()) {
            return __iced_k(log.debug("| " + s + ": preserving temporary keyring by command-line flag"));
          } else {
            (function(__iced_k) {
              if (_this.keyring().is_temporary()) {
                log.debug("| " + s + ": Rolling back temporary key");
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                    funcname: "GpgKey.rollback"
                  });
                  _this.remove(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 189
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k(log.debug("| " + s + ": no need to rollback key, it's permanent"));
              }
            })(__iced_k);
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.make_from_user = function(_arg) {
      var keyring, secret, user, _ref2, _ref3;
      user = _arg.user, secret = _arg.secret, keyring = _arg.keyring;
      return new GpgKey({
        user: user,
        secret: secret,
        username: user.username(),
        is_self: user.is_self(),
        uid: user.id,
        key_data: user != null ? (_ref2 = user.public_keys) != null ? (_ref3 = _ref2.primary) != null ? _ref3.bundle : void 0 : void 0 : void 0,
        keyring: keyring,
        fingerprint: user.fingerprint(true)
      });
    };

    GpgKey.prototype.copy_to_keyring = function(keyring) {
      var d, k, ret, v;
      d = {};
      for (k in this) {
        v = this[k];
        if (k[0] === '_') {
          d[k.slice(1)] = v;
        }
      }
      ret = new GpgKey(d);
      ret._keyring = keyring;
      return ret;
    };

    GpgKey.prototype._find_key_in_stderr = function(which, buf) {
      var d, err, fingerprint, ki64, m;
      err = ki64 = fingerprint = null;
      d = buf.toString('utf8');
      if ((m = d.match(/Primary key fingerprint: (.*)/)) != null) {
        fingerprint = m[1];
      } else if ((m = d.match(/using [RD]SA key ([A-F0-9]{16})/)) != null) {
        ki64 = m[1];
      } else {
        err = new E.VerifyError("" + which + ": can't parse PGP output in verify signature");
      }
      return {
        err: err,
        ki64: ki64,
        fingerprint: fingerprint
      };
    };

    GpgKey.prototype._verify_key_id_64 = function(_arg, cb) {
      var a, b, err, ki64, m, out, sig, which, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      ki64 = _arg.ki64, which = _arg.which, sig = _arg.sig;
      log.debug("+ GpgKey::_verify_key_id_64: " + which + ": " + ki64 + " vs " + (this.fingerprint()));
      err = null;
      (function(_this) {
        return (function(__iced_k) {
          if (ki64 !== _this.key_id_64()) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                funcname: "GpgKey._verify_key_id_64"
              });
              _this.gpg({
                args: ["--fingerprint", "--keyid-format", "long", ki64]
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return out = arguments[1];
                  };
                })(),
                lineno: 234
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(err != null ? void 0 : (m = out.toString('utf8').match(/Key fingerprint = ([A-F0-9 ]+)/)) == null ? err = new E.VerifyError("Querying for a fingerprint failed") : !(a = strip(m[1])) === (b = _this.fingerprint()) ? err = new E.VerifyError("Fingerprint mismatch: " + a + " != " + b) : log.debug("| Successful map of " + ki64 + " -> " + (_this.fingerprint())));
            });
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (err == null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                  funcname: "GpgKey._verify_key_id_64"
                });
                _this.keyring().assert_no_collision(ki64, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 244
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            log.debug("- GpgKey::_verify_key_id_64: " + which + ": " + ki64 + " vs " + (_this.fingerprint()) + " -> " + err);
            return cb(err);
          });
        };
      })(this));
    };

    GpgKey.prototype.verify_sig = function(_arg, cb) {
      var a, b, err, esc, fingerprint, ki64, msg, out, payload, sig, stderr, which, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      which = _arg.which, sig = _arg.sig, payload = _arg.payload;
      log.debug("+ GpgKey::verify_sig " + which);
      esc = make_esc(cb, "GpgKEy::verify_sig");
      err = null;
      stderr = new BufferOutStream();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "GpgKey.verify_sig"
          });
          _this.gpg({
            args: ["--decrypt", "--keyid-format", "long"],
            stdin: sig,
            stderr: stderr
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return out = arguments[1];
              };
            })(),
            lineno: 257
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          msg = err != null ? "signature verification failed" : (a = out.toString('utf8')) !== (b = payload) ? "wrong payload: " + a + " != " + b : null;
          (function(__iced_k) {
            if (msg != null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                  funcname: "GpgKey.verify_sig"
                });
                athrow((new E.VerifyError("" + which + ": " + msg))(esc(__iced_deferrals.defer({
                  lineno: 265
                }))));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            var _ref2;
            _ref2 = _this._find_key_in_stderr(which, stderr.data()), err = _ref2.err, ki64 = _ref2.ki64, fingerprint = _ref2.fingerprint;
            (function(__iced_k) {
              if (err) {
                return __iced_k();
              } else {
                (function(__iced_k) {
                  if (ki64 != null) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                        funcname: "GpgKey.verify_sig"
                      });
                      _this._verify_key_id_64({
                        which: which,
                        ki64: ki64,
                        sig: sig
                      }, esc(__iced_deferrals.defer({
                        lineno: 273
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  } else {
                    return __iced_k((a = strip(fingerprint)) !== (b = _this.fingerprint()) ? err = new E.VerifyError("" + which + ": mismatched fingerprint: " + a + " != " + b) : void 0);
                  }
                })(__iced_k);
              }
            })(function() {
              log.debug("- GpgKey::verify_sig " + which + " -> " + err);
              return cb(err);
            });
          });
        };
      })(this));
    };

    return GpgKey;

  })();

  exports.BaseKeyRing = BaseKeyRing = (function(_super) {
    __extends(BaseKeyRing, _super);

    function BaseKeyRing() {}

    BaseKeyRing.prototype.make_key = function(opts) {
      opts.keyring = this;
      return new GpgKey(opts);
    };

    BaseKeyRing.prototype.make_key_from_user = function(user, secret) {
      return GpgKey.make_from_user({
        user: user,
        secret: secret,
        keyring: this
      });
    };

    BaseKeyRing.prototype.is_temporary = function() {
      return false;
    };

    BaseKeyRing.prototype.gpg = function(gargs, cb) {
      var err, res, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      log.debug("| Call to gpg: " + (util.inspect(gargs)));
      if (gargs.quiet && env().get_debug()) {
        gargs.quiet = false;
      }
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "BaseKeyRing.gpg"
          });
          _this.run(gargs, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return res = arguments[1];
              };
            })(),
            lineno: 309
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, res);
        };
      })(this));
    };

    return BaseKeyRing;

  })(GPG);

  exports.MasterKeyRing = MasterKeyRing = (function(_super) {
    __extends(MasterKeyRing, _super);

    function MasterKeyRing() {
      return MasterKeyRing.__super__.constructor.apply(this, arguments);
    }

    MasterKeyRing.prototype.to_string = function() {
      return "master keyring";
    };

    return MasterKeyRing;

  })(BaseKeyRing);

  _mring = new MasterKeyRing();

  exports.master_ring = master_ring = function() {
    return _mring;
  };

  exports.load_key = function(opts, cb) {
    var err, key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = master_ring().make_key(opts);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
          funcname: "load_key"
        });
        key.load(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 326
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        return cb(err, key);
      };
    })(this));
  };

  exports.TmpKeyRing = TmpKeyRing = (function(_super) {
    __extends(TmpKeyRing, _super);

    function TmpKeyRing(dir) {
      this.dir = dir;
    }

    TmpKeyRing.prototype.to_string = function() {
      return "tmp keyring " + this.dir;
    };

    TmpKeyRing.prototype.mkfile = function(n) {
      return path.join(this.dir, n);
    };

    TmpKeyRing.prototype.mutate_args = function(gargs) {
      gargs.args = ["--no-default-keyring", "--keyring", this.mkfile("pub.ring"), "--secret-keyring", this.mkfile("sec.ring"), "--trustdb-name", this.mkfile("trust.db")].concat(gargs.args);
      return log.debug("| Mutate GPG args; new args: " + (gargs.args.join(' ')));
    };

    TmpKeyRing.make = function(cb) {
      var dir, err, made, mode, nxt, parent, so, tkr, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      mode = 0x1c0;
      log.debug("+ Make new temporary keychain");
      parent = env().get_tmp_keyring_dir();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "TmpKeyRing.make"
          });
          mkdirp(parent, mode, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return made = arguments[1];
              };
            })(),
            lineno: 362
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (err != null) {
              return __iced_k(log.error("Error making tmp keyring dir " + parent + ": " + err.message));
            } else {
              (function(__iced_k) {
                if (made) {
                  return __iced_k(log.info("Creating tmp keyring dir: " + parent));
                } else {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                      funcname: "TmpKeyRing.make"
                    });
                    fs.stat(parent, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          err = arguments[0];
                          return so = arguments[1];
                        };
                      })(),
                      lineno: 368
                    }));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      if (err != null) {
                        return __iced_k(log.error("Failed to stat directory " + parent + ": " + err.message));
                      } else {
                        (function(__iced_k) {
                          if ((so.mode & 0x1ff) !== mode) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                                funcname: "TmpKeyRing.make"
                              });
                              fs.chmod(dir, mode, __iced_deferrals.defer({
                                assign_fn: (function() {
                                  return function() {
                                    return err = arguments[0];
                                  };
                                })(),
                                lineno: 372
                              }));
                              __iced_deferrals._fulfill();
                            })(function() {
                              return __iced_k(err != null ? log.error("Failed to change mode of " + parent + " to " + mode + ": " + err.message) : void 0);
                            });
                          } else {
                            return __iced_k();
                          }
                        })(__iced_k);
                      }
                    })(__iced_k);
                  });
                }
              })(__iced_k);
            }
          })(function() {
            (function(__iced_k) {
              if (typeof err === "undefined" || err === null) {
                nxt = base64u.encode(prng(12));
                dir = path.join(parent, nxt);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                    funcname: "TmpKeyRing.make"
                  });
                  fs.mkdir(dir, mode, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 379
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  log.debug("| making directory " + dir);
                  return __iced_k(typeof err !== "undefined" && err !== null ? log.error("Failed to make dir " + dir + ": " + err.message) : void 0);
                });
              } else {
                return __iced_k();
              }
            })(function() {
              log.debug("- Made new temporary keychain");
              tkr = typeof err !== "undefined" && err !== null ? null : new TmpKeyRing(dir);
              return cb(err, tkr);
            });
          });
        };
      })(this));
    };

    TmpKeyRing.prototype.copy_key = function(k1, cb) {
      var esc, k2, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "TmpKeyRing::copy_key");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "TmpKeyRing.copy_key"
          });
          k1.load(esc(__iced_deferrals.defer({
            lineno: 392
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          k2 = k1.copy_to_keyring(_this);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
              funcname: "TmpKeyRing.copy_key"
            });
            k2.save(esc(__iced_deferrals.defer({
              lineno: 394
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb();
          });
        };
      })(this));
    };

    TmpKeyRing.prototype.is_temporary = function() {
      return true;
    };

    TmpKeyRing.prototype.nuke = function(cb) {
      var e2, err, file, files, fp, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "TmpKeyRing.nuke"
          });
          fs.readdir(_this.dir, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return files = arguments[1];
              };
            })(),
            lineno: 404
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (typeof err !== "undefined" && err !== null) {
              return __iced_k(log.error("Cannot read dir " + _this.dir + ": " + err.message));
            } else {
              (function(__iced_k) {
                var _i, _len, _ref2, _results, _while;
                _ref2 = files;
                _len = _ref2.length;
                _i = 0;
                _results = [];
                _while = function(__iced_k) {
                  var _break, _continue, _next;
                  _break = function() {
                    return __iced_k(_results);
                  };
                  _continue = function() {
                    return iced.trampoline(function() {
                      ++_i;
                      return _while(__iced_k);
                    });
                  };
                  _next = function(__iced_next_arg) {
                    _results.push(__iced_next_arg);
                    return _continue();
                  };
                  if (!(_i < _len)) {
                    return _break();
                  } else {
                    file = _ref2[_i];
                    fp = path.join(_this.dir, file);
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                        funcname: "TmpKeyRing.nuke"
                      });
                      fs.unlink(fp, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return e2 = arguments[0];
                          };
                        })(),
                        lineno: 410
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      return _next(typeof e2 !== "undefined" && e2 !== null ? (log.warn("Could not remove dir " + fp + ": " + e2.message), err = e2) : void 0);
                    });
                  }
                };
                _while(__iced_k);
              })(function() {
                (function(__iced_k) {
                  if (typeof err === "undefined" || err === null) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                        funcname: "TmpKeyRing.nuke"
                      });
                      fs.rmdir(_this.dir, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return err = arguments[0];
                          };
                        })(),
                        lineno: 415
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      return __iced_k(typeof err !== "undefined" && err !== null ? log.error("Cannot delete tmp keyring @dir: " + err.message) : void 0);
                    });
                  } else {
                    return __iced_k();
                  }
                })(__iced_k);
              });
            }
          })(function() {
            return cb(err);
          });
        };
      })(this));
    };

    return TmpKeyRing;

  })(BaseKeyRing);

}).call(this);
