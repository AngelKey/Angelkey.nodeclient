// Generated by IcedCoffeeScript 1.6.3-i
(function() {
  var TempKeyRing, base64u, constants, db, env, fs, gpg, iced, log, make_esc, mkdirp, path, prng, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  db = require('./db').db;

  gpg = require('./gpg').gpg;

  log = require('./log');

  constants = require('./constants').constants;

  make_esc = require('iced-error').make_esc;

  mkdirp = require('mkdirp');

  env = require('./env').env;

  prng = require('crypto').prng;

  base64u = require('pgp-utils').util.base64u;

  path = require('path');

  fs = require('fs');

  exports.clean_key_imports = function(cb) {
    var args, err, esc, k, keys, state, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    esc = make_esc(cb, "clean_key_imports");
    log.debug("+ clean key imports");
    state = constants.import_state.TEMPORARY;
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
          funcname: "clean_key_imports"
        });
        db.select_key_imports_by_state(state, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return keys = arguments[0];
            };
          })(),
          lineno: 19
        })));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        log.debug("| queried for temp keys, got: " + (JSON.stringify(keys)));
        (function(__iced_k) {
          if (keys.length) {
            args = ["--batch", "--delete-keys"].concat((function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = keys.length; _i < _len; _i++) {
                k = keys[_i];
                _results.push(k.toUpperCase());
              }
              return _results;
            })());
            log.debug("| calling GPG client with " + (JSON.stringify(args)));
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                funcname: "clean_key_imports"
              });
              gpg({
                args: args,
                tmp: true
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 24
              }));
              __iced_deferrals._fulfill();
            })(function() {
              state = constants.import_state.CANCELED;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                  funcname: "clean_key_imports"
                });
                db.batch_update_key_import({
                  fingerprints: keys,
                  state: state
                }, esc(__iced_deferrals.defer({
                  lineno: 26
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            });
          } else {
            return __iced_k();
          }
        })(function() {
          log.debug("- clean key imports");
          return cb(null);
        });
      };
    })(this));
  };

  exports.TempKeyRing = TempKeyRing = (function() {
    function TempKeyRing(dir) {
      this.dir = dir;
    }

    TempKeyRing.make = function(cb) {
      var dir, err, made, mode, nxt, parent, so, tkr, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      mode = 0x1c0;
      parent = env().get_tmp_keyring_dir();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "TempKeyRing.make"
          });
          mkdirp(parent, mode, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return made = arguments[1];
              };
            })(),
            lineno: 39
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (err != null) {
              return __iced_k(log.error("Error making tmp keyring dir " + parent + ": " + err.message));
            } else {
              (function(__iced_k) {
                if (made) {
                  return __iced_k(log.info("Creating tmp keyring dir: " + parent));
                } else {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                      funcname: "TempKeyRing.make"
                    });
                    fs.stat(parent, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          err = arguments[0];
                          return so = arguments[1];
                        };
                      })(),
                      lineno: 45
                    }));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      if (err != null) {
                        return __iced_k(log.error("Failed to stat directory " + parent + ": " + err.message));
                      } else {
                        (function(__iced_k) {
                          if ((so.mode & 0x1ff) !== mode) {
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                                funcname: "TempKeyRing.make"
                              });
                              fs.chmod(dir, mode, __iced_deferrals.defer({
                                assign_fn: (function() {
                                  return function() {
                                    return err = arguments[0];
                                  };
                                })(),
                                lineno: 49
                              }));
                              __iced_deferrals._fulfill();
                            })(function() {
                              return __iced_k(err != null ? log.error("Failed to change mode of " + parent + " to " + mode + ": " + err.message) : void 0);
                            });
                          } else {
                            return __iced_k();
                          }
                        })(__iced_k);
                      }
                    })(__iced_k);
                  });
                }
              })(__iced_k);
            }
          })(function() {
            (function(__iced_k) {
              if (typeof err === "undefined" || err === null) {
                nxt = base64u.encode(prng(12));
                dir = path.join(parent, nxt);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                    funcname: "TempKeyRing.make"
                  });
                  fs.mkdir(dir, mode, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 56
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  log.debug("| making directory " + dir);
                  return __iced_k(typeof err !== "undefined" && err !== null ? log.error("Failed to make dir " + dir + ": " + err.message) : void 0);
                });
              } else {
                return __iced_k();
              }
            })(function() {
              tkr = typeof err !== "undefined" && err !== null ? null : new TempKeyRing(dir);
              return cb(err, tkr);
            });
          });
        };
      })(this));
    };

    TempKeyRing.prototype.nuke = function(cb) {
      var e2, err, file, files, fp, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
            funcname: "TempKeyRing.nuke"
          });
          fs.readdir(_this.dir, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return files = arguments[1];
              };
            })(),
            lineno: 67
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (typeof err !== "undefined" && err !== null) {
              return __iced_k(log.error("Cannot read dir " + _this.dir + ": " + err.message));
            } else {
              (function(__iced_k) {
                var _i, _len, _ref, _results, _while;
                _ref = files;
                _len = _ref.length;
                _i = 0;
                _results = [];
                _while = function(__iced_k) {
                  var _break, _continue, _next;
                  _break = function() {
                    return __iced_k(_results);
                  };
                  _continue = function() {
                    return iced.trampoline(function() {
                      ++_i;
                      return _while(__iced_k);
                    });
                  };
                  _next = function(__iced_next_arg) {
                    _results.push(__iced_next_arg);
                    return _continue();
                  };
                  if (!(_i < _len)) {
                    return _break();
                  } else {
                    file = _ref[_i];
                    fp = path.join(_this.dir, file);
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                        funcname: "TempKeyRing.nuke"
                      });
                      fs.unlink(fp, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return e2 = arguments[0];
                          };
                        })(),
                        lineno: 73
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      return _next(typeof e2 !== "undefined" && e2 !== null ? (log.warn("Could not remove dir " + fp + ": " + e2.message), err = e2) : void 0);
                    });
                  }
                };
                _while(__iced_k);
              })(function() {
                (function(__iced_k) {
                  if (typeof err === "undefined" || err === null) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase-node-client/src/keyring.iced",
                        funcname: "TempKeyRing.nuke"
                      });
                      fs.rmdir(_this.dir, __iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return err = arguments[0];
                          };
                        })(),
                        lineno: 78
                      }));
                      __iced_deferrals._fulfill();
                    })(function() {
                      return __iced_k(typeof err !== "undefined" && err !== null ? log.error("Cannot delete tmp keyring @dir: " + err.message) : void 0);
                    });
                  } else {
                    return __iced_k();
                  }
                })(__iced_k);
              });
            }
          })(function() {
            return cb(err);
          });
        };
      })(this));
    };

    return TempKeyRing;

  })();

}).call(this);
