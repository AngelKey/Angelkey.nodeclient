// Generated by IcedCoffeeScript 1.7.1-a
(function() {
  var E, KeyPatcher, constants, env, iced, log, make_esc, master_ring, prompt_for_int, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script').iced;
  __iced_k = __iced_k_noop = function() {};

  constants = require('./constants').constants;

  make_esc = require('iced-error').make_esc;

  master_ring = require('./keyring').master_ring;

  prompt_for_int = require('./prompter').prompt_for_int;

  env = require('./env').env;

  log = require('./log');

  E = require('./err').E;

  exports.KeyPatcher = KeyPatcher = (function() {
    function KeyPatcher(_arg) {
      var kbpgp;
      this.key = _arg.key;
      this.ring || (this.ring = master_ring());
      kbpgp = require('kbpgp');
      this.lib = {
        KeyManager: kbpgp.KeyManager,
        UserID: kbpgp.opkts.UserID,
        parse: kbpgp.parser.parse
      };
      this.did_patch = false;
      this.em = env().keybase_email();
    }

    KeyPatcher.prototype.import_key = function(cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-client/src/keypatch.iced",
            funcname: "KeyPatcher.import_key"
          });
          _this.lib.KeyManager.import_from_armored_pgp({
            raw: _this.key.key_data()
          }, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                err = arguments[0];
                return __slot_1.km = arguments[1];
              };
            })(_this),
            lineno: 28
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    KeyPatcher.prototype.needs_patch = function() {
      return !this.key.has_canonical_username();
    };

    KeyPatcher.prototype.run_patch = function(cb) {
      var esc, pgp, uid;
      esc = make_esc(cb, "KeyPatcher::run_patch");
      pgp = this.km.pgp;
      console.log(env().make_pgp_uid());
      uid = this.lib.UserID.make(env().make_pgp_uid());
      pgp.userids = [uid];
      pgp.subkeys = [];
      return cb(new Error("bailing out for debugging purposes"));
    };

    KeyPatcher.prototype.prompt_patch = function(cb) {
      var em, err, go, i, prompt, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      em = this.uid.get_email();
      log.console.log("\nKeybase forwards mail for its users to the email addresses of their choice.\nThis feature works much better (and your email is less likely to be marked as spam)\nif you add your Keybase.io identity --- <" + em + "> --- to your key.\nWould you like to:\n\n    (1) Allow this program to add your keybase email to your key (we'll prompt your for your password)\n    (2) Quit out and edit your key via GPG (add email " + em + ")\n    (3) Skip this step\n");
      prompt = "Your choice";
      err = null;
      go = false;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-client/src/keypatch.iced",
            funcname: "KeyPatcher.prompt_patch"
          });
          prompt_for_int(prompt, 1, 3, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return i = arguments[1];
              };
            })(),
            lineno: 75
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (err == null) {
            switch (i) {
              case 1:
                go = true;
                break;
              case 2:
                err = new E.CancelError("please edit your key and rerun this command");
                break;
              case 3:
                go = false;
            }
          }
          return cb(err, go);
        };
      })(this));
    };

    KeyPatcher.prototype.run = function(_arg, cb) {
      var esc, go, interactive, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      interactive = _arg.interactive;
      esc = make_esc(cb, "KeyPatcher::run_patch");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/node-client/src/keypatch.iced",
            funcname: "KeyPatcher.run"
          });
          _this.import_key(esc(__iced_deferrals.defer({
            lineno: 90
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (_this.needs_patch()) {
              _this.uid = _this.lib.UserID.make(env().make_pgp_uid());
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/node-client/src/keypatch.iced",
                  funcname: "KeyPatcher.run"
                });
                _this.prompt_patch(esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return go = arguments[0];
                    };
                  })(),
                  lineno: 94
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k(go = false);
            }
          })(function() {
            (function(__iced_k) {
              if (go) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/node-client/src/keypatch.iced",
                    funcname: "KeyPatcher.run"
                  });
                  _this.run_patch(esc(__iced_deferrals.defer({
                    lineno: 98
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              return cb(null, _this.did_patch);
            });
          });
        };
      })(this));
    };

    return KeyPatcher;

  })();

}).call(this);
