// Generated by IcedCoffeeScript 1.6.3-j
(function() {
  var BaseSigGen, KeybaseProofGen, KeybasePushProofGen, SignatureEngine, TrackerProofGen, TwitterProofGen, UntrackerProofGen, constants, decode, env, gpg, iced, log, make_esc, proofs, req, session, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  proofs = require('keybase-proofs');

  make_esc = require('iced-error').make_esc;

  req = require('./req');

  constants = require('./constants').constants;

  session = require('./session');

  env = require('./env').env;

  log = require('./log');

  gpg = require('gpg-wrapper').gpg;

  decode = require('pgp-utils').armor.decode;

  BaseSigGen = (function() {
    function BaseSigGen(_arg) {
      this.km = _arg.km;
    }

    BaseSigGen.prototype._get_seqno_type = function() {
      return "PUBLIC";
    };

    BaseSigGen.prototype._get_announce_number = function(cb) {
      var body, err, type, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      type = this._get_seqno_type();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/sigs.iced",
            funcname: "BaseSigGen._get_announce_number"
          });
          req.get({
            endpoint: "sig/next_seqno",
            args: {
              type: type
            }
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return body = arguments[1];
              };
            })(),
            lineno: 24
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            _this.seqno = body.seqno;
            _this.prev = body.prev;
          }
          return cb(err);
        };
      })(this));
    };

    BaseSigGen.prototype._get_binding_eng = function() {
      return this._make_binding_eng({
        sig_eng: new SignatureEngine({
          km: this.km
        }),
        seqno: this.seqno,
        prev: this.prev,
        host: constants.canonical_host,
        user: {
          local: {
            uid: env().get_uid(),
            username: env().get_username()
          }
        }
      });
    };

    BaseSigGen.prototype._do_signature = function(cb) {
      var eng, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      eng = this._get_binding_eng();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/sigs.iced",
            funcname: "BaseSigGen._do_signature"
          });
          eng.generate(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                err = arguments[0];
                return __slot_1.sig = arguments[1];
              };
            })(_this),
            lineno: 48
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    BaseSigGen.prototype._v_modify_store_arg = function(arg) {};

    BaseSigGen.prototype._get_api_endpoint = function() {
      return "sig/post";
    };

    BaseSigGen.prototype._store_signature = function(cb) {
      var args, body, endpoint, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = {
        sig: this.sig.pgp,
        sig_id_base: this.sig.id,
        sig_id_short: this.sig.short_id,
        is_remote_proof: true
      };
      this._v_modify_store_arg(args);
      endpoint = this._get_api_endpoint();
      log.debug("+ storing signature:");
      log.debug("| writing to " + endpoint);
      log.debug("| with args " + (JSON.stringify(args)));
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/sigs.iced",
            funcname: "BaseSigGen._store_signature"
          });
          req.post({
            endpoint: endpoint,
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return body = arguments[1];
              };
            })(),
            lineno: 69
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            _this.proof_text = body.proof_text;
            _this.proof_id = body.proof_id;
          }
          log.debug("- stored signature (err = " + (typeof err !== "undefined" && err !== null ? err.message : void 0) + ")");
          return cb(err);
        };
      })(this));
    };

    BaseSigGen.prototype.run = function(cb) {
      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "BaseSigGen::run");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/sigs.iced",
            funcname: "BaseSigGen.run"
          });
          _this._get_announce_number(esc(__iced_deferrals.defer({
            lineno: 80
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase-node-client/src/sigs.iced",
              funcname: "BaseSigGen.run"
            });
            _this._do_signature(esc(__iced_deferrals.defer({
              lineno: 81
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/sigs.iced",
                funcname: "BaseSigGen.run"
              });
              _this._store_signature(esc(__iced_deferrals.defer({
                lineno: 82
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null, _this.sig);
            });
          });
        };
      })(this));
    };

    return BaseSigGen;

  })();

  exports.KeybaseProofGen = KeybaseProofGen = (function(_super) {
    __extends(KeybaseProofGen, _super);

    function KeybaseProofGen() {
      return KeybaseProofGen.__super__.constructor.apply(this, arguments);
    }

    KeybaseProofGen.prototype._v_modify_store_arg = function(arg) {
      arg.type = "web_service_binding.keybase";
      return arg.is_remote_proof = false;
    };

    KeybaseProofGen.prototype._make_binding_eng = function(arg) {
      return new proofs.KeybaseBinding(arg);
    };

    return KeybaseProofGen;

  })(BaseSigGen);

  exports.KeybasePushProofGen = KeybasePushProofGen = (function(_super) {
    __extends(KeybasePushProofGen, _super);

    function KeybasePushProofGen() {
      return KeybasePushProofGen.__super__.constructor.apply(this, arguments);
    }

    KeybasePushProofGen.prototype._store_signature = function(cb) {
      return cb(null);
    };

    KeybasePushProofGen.prototype._make_binding_eng = function(arg) {
      return new proofs.KeybaseBinding(arg);
    };

    return KeybasePushProofGen;

  })(BaseSigGen);

  exports.TrackerProofGen = TrackerProofGen = (function(_super) {
    __extends(TrackerProofGen, _super);

    function TrackerProofGen(_arg) {
      var km;
      km = _arg.km, this.prev = _arg.prev, this.seqno = _arg.seqno, this.uid = _arg.uid, this.track = _arg.track;
      TrackerProofGen.__super__.constructor.call(this, {
        km: km
      });
    }

    TrackerProofGen.prototype._get_announce_number = function(cb) {
      return cb(null);
    };

    TrackerProofGen.prototype._make_binding_eng = function(arg) {
      arg.track = this.track;
      return new proofs.Track(arg);
    };

    TrackerProofGen.prototype._v_modify_store_arg = function(arg) {
      arg.uid = this.uid;
      return arg.type = "track";
    };

    TrackerProofGen.prototype._get_api_endpoint = function() {
      return "follow";
    };

    return TrackerProofGen;

  })(BaseSigGen);

  exports.UntrackerProofGen = UntrackerProofGen = (function(_super) {
    __extends(UntrackerProofGen, _super);

    function UntrackerProofGen(_arg) {
      var km;
      km = _arg.km, this.uid = _arg.uid, this.untrack = _arg.untrack, this.seqno = _arg.seqno, this.prev = _arg.prev;
      UntrackerProofGen.__super__.constructor.call(this, {
        km: km
      });
    }

    UntrackerProofGen.prototype._get_announce_number = function(cb) {
      return cb(null);
    };

    UntrackerProofGen.prototype._make_binding_eng = function(arg) {
      arg.untrack = this.untrack;
      return new proofs.Untrack(arg);
    };

    UntrackerProofGen.prototype._v_modify_store_arg = function(arg) {
      arg.uid = this.uid;
      return arg.type = "untrack";
    };

    UntrackerProofGen.prototype._get_api_endpoint = function() {
      return "follow";
    };

    return UntrackerProofGen;

  })(BaseSigGen);

  exports.TwitterProofGen = TwitterProofGen = (function(_super) {
    __extends(TwitterProofGen, _super);

    function TwitterProofGen(args) {
      this.remote_username = args.remote_username;
      TwitterProofGen.__super__.constructor.call(this, args);
    }

    TwitterProofGen.prototype._make_binding_eng = function(args) {
      args.user.remote = this.remote_username;
      return new proofs.TwitterBinding(args);
    };

    TwitterProofGen.prototype._v_modify_store_arg = function(arg) {
      arg.remote_username = this.remote_username;
      return arg.type = "web_service_binding.twitter";
    };

    return TwitterProofGen;

  })(BaseSigGen);

  exports.SignatureEngine = SignatureEngine = (function() {
    function SignatureEngine(_arg) {
      this.km = _arg.km;
    }

    SignatureEngine.prototype.get_km = function() {
      return this.km;
    };

    SignatureEngine.prototype.box = function(msg, cb) {
      var arg, err, out, pgp, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      out = {};
      arg = {
        stdin: new Buffer(msg, 'utf8'),
        args: ["-u", this.km.get_pgp_key_id(), "--sign", "-a"]
      };
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/sigs.iced",
            funcname: "SignatureEngine.box"
          });
          gpg(arg, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return pgp = arguments[1];
              };
            })(),
            lineno: 176
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _ref;
          if (typeof err === "undefined" || err === null) {
            out.pgp = pgp = pgp.toString('utf8');
            _ref = decode(pgp), err = _ref[0], msg = _ref[1];
            if (err == null) {
              out.raw = msg.body;
            }
          }
          return cb(err, out);
        };
      })(this));
    };

    return SignatureEngine;

  })();

}).call(this);
