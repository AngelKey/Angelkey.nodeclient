// Generated by IcedCoffeeScript 1.6.3-i
(function() {
  var BufferOutStream, E, GpgKey, IS, assert_no_collision, db, gpg, iced, log, make_esc, read_uids_from_key, strip, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('./gpg'), gpg = _ref.gpg, assert_no_collision = _ref.assert_no_collision, read_uids_from_key = _ref.read_uids_from_key;

  E = require('./err').E;

  db = require('./db').db;

  make_esc = require('iced-error').make_esc;

  IS = require('./constants').constants.import_state;

  log = require('./log');

  BufferOutStream = require('gpg-wrapper').BufferOutStream;

  strip = function(m) {
    return m.split(/\s+/).join('');
  };

  exports.GpgKey = GpgKey = (function() {
    function GpgKey(user, _arg) {
      var secret, _ref1, _ref2;
      this.user = user;
      secret = _arg.secret;
      this._fingerprint = this.user.fingerprint(true);
      this._username = this.user.username();
      this._is_self = this.user._is_self;
      this._secret = secret;
      this._uid = this.user.id;
      this._public_key_data = (_ref1 = this.user.public_keys) != null ? (_ref2 = _ref1.primary) != null ? _ref2.bundle : void 0 : void 0;
    }

    GpgKey.prototype.fingerprint = function() {
      return this._fingerprint;
    };

    GpgKey.prototype.username = function() {
      return this._username;
    };

    GpgKey.prototype.key_id_64 = function() {
      return this.fingerprint().slice(-16);
    };

    GpgKey.prototype.key_id_32 = function() {
      return this.fingerprint().slice(-8);
    };

    GpgKey.prototype.query_key = function(cb) {
      var args, err, fp, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          if ((fp = _this._fingerprint) != null) {
            args = ["-" + (_this._secret ? 'K' : 'k'), fp];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                funcname: "GpgKey.query_key"
              });
              gpg({
                args: args,
                quiet: true
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return out = arguments[1];
                  };
                })(),
                lineno: 40
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(typeof err !== "undefined" && err !== null ? err = new E.NoLocalKeyError((_this._is_self ? "You don't have a local key!" : "the user " + _this._username + " doesn't have a local key")) : _this._import_state = IS.FINAL);
            });
          } else {
            return __iced_k(err = new E.NoRemoteKeyError((_this._is_self ? "You don't have a registered remote key! Try `keybase push`" : "the user " + _this._username + " doesn't have a remote key")));
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.import_key = function(cb) {
      var args, data, err, fingerprint, found, out, uid, un, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      un = this._username;
      uid = this._uid;
      fingerprint = this._fingerprint;
      found = false;
      log.debug("+ " + un + ": import public key");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
            funcname: "GpgKey.import_key"
          });
          _this.query_key(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 63
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (typeof err === "undefined" || err === null) {
              log.debug("| found locally");
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                  funcname: "GpgKey.import_key"
                });
                db.get_import_state({
                  uid: uid,
                  fingerprint: fingerprint
                }, __iced_deferrals.defer({
                  assign_fn: (function(__slot_1) {
                    return function() {
                      err = arguments[0];
                      return __slot_1._import_state = arguments[1];
                    };
                  })(_this),
                  lineno: 66
                }));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(log.debug("| read state from DB as " + _this._import_state));
              });
            } else {
              (function(__iced_k) {
                if ((err instanceof E.NoLocalKeyError) == null) {
                  return __iced_k();
                } else {
                  (function(__iced_k) {
                    if ((data = _this._public_key_data) == null) {
                      return __iced_k(err = new E.ImportError("no public key found for " + un));
                    } else {
                      log.debug("| temporarily importing key to scratch GPG keychain");
                      _this._import_state = IS.TEMPORARY;
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                          funcname: "GpgKey.import_key"
                        });
                        _this._db_log(__iced_deferrals.defer({
                          assign_fn: (function() {
                            return function() {
                              return err = arguments[0];
                            };
                          })(),
                          lineno: 74
                        }));
                        __iced_deferrals._fulfill();
                      })(function() {
                        (function(__iced_k) {
                          if (err == null) {
                            args = ["--import"];
                            (function(__iced_k) {
                              __iced_deferrals = new iced.Deferrals(__iced_k, {
                                parent: ___iced_passed_deferral,
                                filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                                funcname: "GpgKey.import_key"
                              });
                              _this.gpg({
                                args: args,
                                stdin: data,
                                quiet: true
                              }, __iced_deferrals.defer({
                                assign_fn: (function() {
                                  return function() {
                                    err = arguments[0];
                                    return out = arguments[1];
                                  };
                                })(),
                                lineno: 77
                              }));
                              __iced_deferrals._fulfill();
                            })(function() {
                              return __iced_k(err != null ? err = new E.ImportError("" + un + ": key import error: " + err.message) : void 0);
                            });
                          } else {
                            return __iced_k();
                          }
                        })(__iced_k);
                      });
                    }
                  })(__iced_k);
                }
              })(__iced_k);
            }
          })(function() {
            log.debug("- " + un + ": imported public key (state=" + _this._import_state + ")");
            return cb(err);
          });
        };
      })(this));
    };

    GpgKey.prototype.is_tmp = function() {
      return (this._import_state == null) || (this._import_state === IS.TEMPORARY);
    };

    GpgKey.prototype._remove = function(cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      log.debug("+ deleting public key " + this._username + "/" + this._fingerprint);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
            funcname: "GpgKey._remove"
          });
          _this.gpg({
            args: ["--batch", "--delete-keys", _this._fingerprint]
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 91
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          log.debug("- deleted public key " + _this._username + "/" + _this._fingerprint);
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype._sign_key = function(signer, cb) {
      var args, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      log.debug("| GPG-signing " + (this.username()) + "'s key with your key");
      args = ["-u", signer.fingerprint(), "--sign-key", "--batch", "--yes", this.fingerprint()];
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
            funcname: "GpgKey._sign_key"
          });
          _this.gpg({
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 100
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.gpg_obj = function() {
      return gpgmod.obj(this.is_tmp());
    };

    GpgKey.prototype._verify_key_id_32 = function(_arg, cb) {
      var a, b, err, ki32, m, out, sig, which, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      ki32 = _arg.ki32, which = _arg.which, sig = _arg.sig;
      log.debug("+ GpgKey::_verify_key_id_32: " + which + ": " + ki32 + " vs " + (this.fingerprint()));
      err = null;
      (function(_this) {
        return (function(__iced_k) {
          if (ki32 !== _this.key_id_32()) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                funcname: "GpgKey._verify_key_id_32"
              });
              _this.gpg({
                args: ["--fingerprint", ki32]
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return out = arguments[1];
                  };
                })(),
                lineno: 113
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(err != null ? void 0 : (m = out.toString('utf8').match(/Key fingerprint = ([A-F0-9 ]+)/)) == null ? err = new E.VerifyError("Querying for a fingerprint failed") : !(a = strip(m[1])) === (b = _this.fingerprint()) ? err = new E.VerifyError("Fingerprint mismatch: " + a + " != " + b) : log.debug("| Successful map of " + ki32 + " -> " + (_this.fingerprint())));
            });
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (err == null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                  funcname: "GpgKey._verify_key_id_32"
                });
                _this.assert_no_collision(ki32, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 123
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            log.debug("- GpgKey::_verify_key_id_32: " + which + ": " + ki32 + " vs " + (_this.fingerprint()) + " -> " + err);
            return cb(err);
          });
        };
      })(this));
    };

    GpgKey.prototype._find_key_in_stderr = function(which, buf) {
      var d, err, fingerprint, ki32, m;
      err = ki32 = fingerprint = null;
      d = buf.toString('utf8');
      if ((m = d.match(/Primary key fingerprint: (.*)/)) != null) {
        fingerprint = m[1];
      } else if ((m = d.match(/using [RD]SA key ID ([A-F0-9]{8})/)) != null) {
        ki32 = m[1];
      } else {
        err = new E.VerifyError("" + which + ": can't parse PGP output in verify signature");
      }
      return {
        err: err,
        ki32: ki32,
        fingerprint: fingerprint
      };
    };

    GpgKey.prototype.verify_sig = function(_arg, cb) {
      var a, b, err, esc, fingerprint, ki32, msg, out, payload, sig, stderr, which, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      which = _arg.which, sig = _arg.sig, payload = _arg.payload;
      log.debug("+ GpgKey::verify_sig " + which);
      esc = make_esc(cb, "GpgKEy::verify_sig");
      err = null;
      stderr = new BufferOutStream();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
            funcname: "GpgKey.verify_sig"
          });
          _this.gpg({
            args: ["--decrypt"],
            stdin: sig,
            stderr: stderr
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return out = arguments[1];
              };
            })(),
            lineno: 146
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          msg = err != null ? "signature verification failed" : (a = out.toString('utf8')) !== (b = payload) ? "wrong payload: " + a + " != " + b : null;
          (function(__iced_k) {
            if (msg != null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                  funcname: "GpgKey.verify_sig"
                });
                athrow((new E.VerifyError("" + which + ": " + msg))(esc(__iced_deferrals.defer({
                  lineno: 154
                }))));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            var _ref1;
            _ref1 = _this._find_key_in_stderr(which, stderr.data()), err = _ref1.err, ki32 = _ref1.ki32, fingerprint = _ref1.fingerprint;
            (function(__iced_k) {
              if (err) {
                return __iced_k();
              } else {
                (function(__iced_k) {
                  if (ki32 != null) {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                        funcname: "GpgKey.verify_sig"
                      });
                      _this._verify_key_id_32({
                        which: which,
                        ki32: ki32,
                        sig: sig
                      }, esc(__iced_deferrals.defer({
                        lineno: 162
                      })));
                      __iced_deferrals._fulfill();
                    })(__iced_k);
                  } else {
                    return __iced_k((a = strip(fingerprint)) !== (b = _this.fingerprint()) ? err = new E.VerifyError("" + which + ": mismatched fingerprint: " + a + " != " + b) : void 0);
                  }
                })(__iced_k);
              }
            })(function() {
              log.debug("- GpgKey::verify_sig " + which + " -> " + err);
              return cb(err);
            });
          });
        };
      })(this));
    };

    GpgKey.prototype.rollback = function(cb) {
      var esc, stdin, un, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "GpgKey::commit");
      (function(_this) {
        return (function(__iced_k) {
          if (_this._import_state === IS.TEMPORARY) {
            un = _this._username;
            log.debug("+ " + un + ": rollback key " + _this._fingerprint);
            stdin = _this._public_key_data;
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                funcname: "GpgKey.rollback"
              });
              _this._remove(esc(__iced_deferrals.defer({
                lineno: 177
              })));
              __iced_deferrals._fulfill();
            })(function() {
              _this._import_state = IS.CANCELED;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                  funcname: "GpgKey.rollback"
                });
                _this._db_log(esc(__iced_deferrals.defer({
                  lineno: 179
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(log.debug("- " + un + ": rollback key " + _this._fingerprint));
              });
            });
          } else {
            return __iced_k(log.debug("| no need to rollback key since it was previously imported"));
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    GpgKey.prototype._db_log = function(cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      log.debug("| DB log update " + this._fingerprint + " -> " + this._import_state);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
            funcname: "GpgKey._db_log"
          });
          db.log_key_import({
            uid: _this._uid,
            state: _this._import_state,
            fingerprint: _this._fingerprint
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 189
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err);
        };
      })(this));
    };

    GpgKey.prototype.read_uids_from_key = function(cb) {
      var err, opts, uids, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      opts = {
        tmp: this.is_tmp(),
        fingerprint: this._fingerprint
      };
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
            funcname: "GpgKey.read_uids_from_key"
          });
          read_uids_from_key(opts, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return uids = arguments[1];
              };
            })(),
            lineno: 198
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, uids);
        };
      })(this));
    };

    GpgKey.prototype.gpg = function(opts, cb) {
      opts.tmp = this.is_tmp();
      return gpg(opts, cb);
    };

    GpgKey.prototype.commit = function(signer, cb) {
      var esc, stdin, un, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "GpgKey::commit");
      un = this._username;
      (function(_this) {
        return (function(__iced_k) {
          if (_this._import_state === IS.TEMPORARY) {
            log.debug("+ " + un + ": remove temporarily imported public key");
            stdin = _this._public_key_data;
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                funcname: "GpgKey.commit"
              });
              _this._remove(esc(__iced_deferrals.defer({
                lineno: 215
              })));
              __iced_deferrals._fulfill();
            })(function() {
              _this._import_state = IS.FINAL;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                  funcname: "GpgKey.commit"
                });
                _this.gpg({
                  args: ["--import"],
                  stdin: stdin,
                  quiet: true
                }, esc(__iced_deferrals.defer({
                  lineno: 217
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                    funcname: "GpgKey.commit"
                  });
                  _this._sign_key(signer, esc(__iced_deferrals.defer({
                    lineno: 218
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/Users/max/src/keybase-node-client/src/gpgkey.iced",
                      funcname: "GpgKey.commit"
                    });
                    _this._db_log(esc(__iced_deferrals.defer({
                      lineno: 219
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(log.debug("- " + un + ": remove temporarily imported public key"));
                  });
                });
              });
            });
          } else {
            return __iced_k(log.debug("| " + un + ": Key was previously commited; noop"));
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    GpgKey.prototype.assert_no_collision = function(short_id, cb) {
      return assert_no_collision({
        short_id: short_id,
        tmp: this.is_tmp()
      }, cb);
    };

    return GpgKey;

  })();

}).call(this);
